11. Криптография(Стивенс Род)
	11.1. Перестановочные шифры
		11.1.1. Перестановка строк/столбцов
		11.1.2. Маршрутные шифры
	11.2. Шифры подстановки
		11.2.1. Шифр Цезаря
		11.2.2. Шифр Виженера
		11.2.3. Простая подстановка
		11.2.4. Схема одноразовых блокнотов
	11.3. Блочные шифры
		11.3.1. Подстановочно-перестановочные сети
		11.3.2. Шифр Фейстеля
	11.4. Примеры шифрования используемые в мире ИТ
		11.4.1. AES
		11.4.2. RSA
		11.4.3. MD5
		11.4.4. SHA1
		11.4.5. SHA256
		11.4.6. SSL
		11.4.7. TLS

11. Криптография(Стивенс Род)
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 365)

Криптография — это исследование методов безопасной передачи информа-
ции, которая потенциально может быть перехвачена злоумышленниками. На
ранних этапах развития криптография представляла собой обычную письмен-
ность; она работала по той простой причине, что немногие тогда, на заре циви-
лизации, умели читать. Позже в обиход вошли специальные алфавиты, извест-
ные только отправителю и получателю. В одном из самых ранних образцов это-
го вида криптографии использовались нестандартные иероглифы, высеченные
в гробницах (Египет, 1900 г. до н. э.).

Другая форма криптографии, популярная в Древней Греции и Спарте, была
основана на использовании деревянного стержня — скиталы. Вокруг него по спи-
рали наматывалась полоска пергамента, на которой записывались слова. Когда
пергамент разворачивали, буквы оказывались в неправильном положении. Что-
бы прочитать сообщение, получатель должен был намотать пергамент на стержень
того же диаметра.

Такой подход к криптографии иногда называют «безопасность через неясность»
(security through obscurity), поскольку в нем предполагается, что злоумышленник
не знает, в чем подвох. Но если вам известен секретный алфавит или то, что сооб-
щение написано на скитале, вы сможете без труда его воспроизвести.

В более современных криптографических методиках исходят из того, что зло-
умышленник знает все о способе шифрования сообщения, кроме небольшого, но
крайне важного фрагмента информации, который называют ключом. Ключ исполь-
зуется как отправителем, чтобы зашифровать данные, так и получателем, чтобы их
расшифровать. Поскольку метод шифрования известен, злоумышленник тоже мо-
жет расшифровать сообщение, получив ключ.

Такой подход к криптографии более надежен, чем безопасность через неясность,
поскольку способ шифрования рано или поздно будет разгадан.

Сначала будут рассмотрены классические подходы. Они больше не
считаются безопасными, но все еще представляют определенный интерес, демон-
стрируя несколько практичных идей вроде частотного анализа.

Криптоанализ (исследование способов взлома и восстановления зашифрован-
ных данных) зародился примерно в те же времена, что и сама криптография. В сле-
дующих разделах описываются не только классические подходы к шифрованию,
но и способы их взлома.


11.1. Перестановочные шифры
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 367)

В перестановочном шифре буквы открытого текста меняются местами каким-то
определенным образом, результатом чего является криптограмма. Чтобы прочитать
сообщение, получатель возвращает буквы на их исходные позиции.

Такие шифры частично полагаются на безопасность через неясность, если зло-
умышленник не знает, какой именно метод перестановки используется. Например,
метод скиталы, описанный в начале этой главы, выполняет перестановку, вызван-
ную обертыванием пергамента вокруг стержня. Он полностью зависит от того, что
злоумышленнику не должен быть известен способ шифрования сообщения.

Большинство из этих методик, помимо прочего, предоставляют ключ, который
несет в себе определенную информацию о перестановке. Например, перестановоч-
ный шифр по строкам/столбцам, описанный в следующем подразделе, использу-
ет в качестве ключа количество столбцов. Однако такие ключи обычно допускают
достаточно ограниченное число значений, поэтому их несложно подобрать и взло-
мать тем самым шифрование, особенно если использовать компьютер.

С такими шифрами довольно легко работать с помощью карандаша и бума-
ги — они могут играть роль занятных упражнений (если они кажутся вам слишком
простыми, попробуйте проводить вычисления в голове).

11.1.1. Перестановка строк/столбцов
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 367)

В перестановочном шифре по строкам/столбцам текстовое сообщение построч-
но записывается в массив. Затем оттуда же считывается криптограмма, но уже по
столбцам. Например, на рисунке 16.1 показано текстовое сообщение THIS IS A
SECRET MESSAGE, построчно записанное в массив размерностью четыре строки на
пять столбцов (обычно, если после сохранения сообщения остаются пустые ячей-
ки, они заполняются буквами X или случайными символами).

T H I S I
S A S E C
R E T M E
S S A G E
Рис. 16.1. В перестановочном шифре по строкам/столбцам открытый текст построчно
записывается в массив, после чего оттуда по столбцам считывается криптограмма

Чтобы получить криптограмму, нужно прочитать каждый столбец сверху вниз.
В нашем примере результат будет выглядеть так: TSRSH AESIS TASEM GICEE.
В качестве ключа выступает количество столбцов, которые использовались при
перестановке.

Для расшифровки криптограммы, в сущности, нужно выполнить операцию
шифрования в обратном порядке. Создается массив, туда по вертикали записыва-
ется криптограмма, а расшифрованное сообщение считывается построчно.

При реализации этого алгоритма текст не обязательно помещать в массив. Если
количество столбцов равно num_columns, вы можете просто считывать содержимое
строки с открытым текстом, пропуская num_columns между каждым символом.
Данный подход представлен на примере следующего псевдокода.

String: ciphertext = «»
For col = 0 To num_columns - 1
	Integer: index = col
	For row = 0 To num_rows - 1
		ciphertext = ciphertext + plaintext[index]
		index += num_columns
	Next row
Next col

При программном дешифровании сообщения стоит принять во внимание сле-
дующее: расшифровка сообщения, изначально записанного в массив с R строками
и C столбцами, идентична его шифрованию в массиве с C строками и R столбцами.

В предыдущем примере сообщение вставлялось в массив размером 4x5. На ри-
сунке 16.2 показана криптограмма TSRSH AESIS TASEM GICEE, построчно запи-
санная в массив размером 5x4. Взглянув на нее, вы увидите, что открытый текст
можно прочитать по столбцам.

T S R S
H A E S
I S T A
S E M G
I C E E
Рис. 16.2. Расшифровывание в массиве RxC эквивалентно шифрованию
в массиве CxR

Перестановка строк/столбцов — довольно простой алгоритм. Это занятное
упражнение, но такую систему относительно легко взломать. В качестве секретного
ключа выступает количество столбцов в массиве. Разбивая строку на отрезки раз-
ной длины, можно получить несколько версий ключа. Например, предыдущая крип-
тограмма содержит 20 символов. 20 делится на 1, 2, 4, 5, 10 и 20 — это все возмож-
ные варианты количества столбцов. Массивы размером 1x20 и 20x1 делают крип-
тограмму идентичной открытому тексту, поэтому для проверки остается всего два
варианта. Попробовав каждое из значений, вы увидите, что при четырех столбцах
у вас получится тарабарщина, а вот при пяти символы сложатся в понятные слова.

Отправитель может попытаться усложнить задачу злоумышленнику, доба-
вив в конец криптограммы какие-нибудь случайные символы (в частности, раз-
мер массива нельзя будет определить лишь длиной сообщения). Например, если
к преды дущей криптограмме добавить девять символов (чтобы получить стро-
ку длиной 29), будет уже не так очевидно, что массив должен состоять из четырех
или пяти столбцов.

Но даже в этом случае не составляет никакого труда написать программу, ко-
торая перебирает все варианты количества столбцов между 2 и 1, которые не пре-
вышают длину криптограммы. Наличие слов в соответствующем расшифрованном
тексте будет означать, что ключ найден.

11.1.2. Маршрутные шифры
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 371)

В маршрутном шифре открытый текст записывается в массив (или упорядо-
чивается каким-то другим способом) и затем считывается из него в порядке, ко-
торый определяется конкретным маршрутом. Например, на рисунке 16.4 показа-
но открытое сообщение, построчно записанное в массив. Криптограмма форми-
руется путем перемещения по диагонали, начиная с левого края массива: SRSSE
ATATG HSMEI EESCI.

T H I S I
S A S E C
R E T M E
S S A G E

Рис. 16.4. В маршрутном шифре открытый текст построчно записывается в массив
и затем считывается оттуда в каком-то другом порядке, формируя криптограмму

Теоретически количество допустимых маршрутов через массив может быть
огромным. Если в массиве содержится N элементов, число маршрутов через него
будет равно N! В примере, показанном на рисунке 16.4, их будет 20! ~ 2,4 * 10^18.

Тем не менее хороший маршрут должен быть достаточно простым, чтобы по-
лучатель мог его запомнить. Диагональный маршрут, показанный на рисунке 16.4,
годится для этой цели, но если он будет перескакивать по всему массиву в произ-
вольном порядке, получателю придется его записать, что сделает ключ таким же
длинным, как и само сообщение. (Позже в текущей главе вы увидите, что то же са-
мое можно сказать и о ключе для схемы одноразовых блокнотов, которая ко все-
му прочему меняет буквы сообщения таким образом, что злоумышленник не мо-
жет получить дополнительную информацию — например, частоту использования
тех или иных букв в сообщении.)

Некоторые маршруты оставляют большие фрагменты текста нетронутыми или
сохраняют их в обратном порядке. Например, спираль, ведущая внутрь по часовой
стрелке, начиная с левого верхнего угла, легко запоминается, но при этом первая
строка сообщения попадает в криптограмму неизменной. Подобные маршруты
дают злоумышленнику дополнительные сведения, что может облегчить их подбор.

Если отказаться от маршрутов, которые сложно запоминаются и содержат круп-
ные фрагменты нетронутого открытого текста, количество оставшихся вариантов
окажется значительно меньше теоретического максимума.

11.2. Шифры подстановки
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 372)

В шифрах подстановки буквы открытого текста заменяются другими. В следу-
ющих разделах описываются четыре распространенных шифра этого типа.

11.2.1. Шифр Цезаря
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 372)

Примерно 2100 лет назад Юлий Цезарь (100 г. до н. э. — 44 г. до н. э.) кодировал
сообщения, которые он отправлял своим офицерам, с помощью простого шифра
подстановки. В этой версии шифра он сдвигал каждый символ сообщения на три
буквы в алфавите. Буква A превращалась в D, B — в E и т. д. Чтобы расшифровать
сообщение, получатель вычитал 3 из каждой буквы: Z становилась W, Y — V и т. д.

Например, сообщение This is a secret message со сдвигом в три позиции выгля-
дит как WKLVL VDVHF UHWPH VVDJH.

Племянник Юлия Цезаря, Август, использовал похожий шифр, только с оди-
нарным сдвигом вместо тройного. В принципе вы можете сдвигать буквы в откры-
том тексте на любое количество символов.

Злоумышленник способен раскодировать сообщение, зашифрованное этим ме-
тодом, изучив частоту использования букв в криптограмме. В английском языке
буква E встречается намного чаще других — приблизительно в 12,7 % случаев. Вто-
рая по популярности буква, T, имеет частоту 9,1 %. Если злоумышленник подсчи-
тает, сколько раз каждая буква встречается в криптограмме, наиболее используе-
мой из них, вероятно, окажется зашифрованная буква E. Посчитав разницу меж-
ду буквой E и закодированным символом, он получит сдвиг, который применял-
ся при шифровании.

Такой метод взлома лучше всего подходит для длинных сообщений, поскольку
в коротких частота распределения букв может оказаться нетипичной.

В таблице 16.1 показано количество вхождений разных букв в криптограмму
WKLVL VDVHF UHWPH VVDJH.

Таблица 16.1. Частота использования букв в вышеприведенной криптограмме

Буква			D F H J K I P U V W
Число вхождений	2 1 4 1 1 2 1 1 5 2

Если предположить, что V — зашифрованная буква E, тогда размер сдвига дол-
жен быть равен 17. Расшифровав сообщение с этим сдвигом, вы получите текст вида
FTUEU EMEQO DQFYQ EEMSQ, который не содержит настоящих слов.

Если принять за E вторую по использованию букву в криптограмме, H, то сдвиг
будет равен 3, что позволит расшифровать исходное сообщение.

11.2.2. Шифр Виженера
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 373)

Шифр Виженера изначально был описан в 1553 г. Джованом Баттистой Бел-
лазо, но в XIX в. его авторство начали приписывать Блезу Виженеру. С тех пор
это название прочно вошло в обиход.

У подстановочного шифра Цезаря есть одна проблема — для него существу-
ет всего 26 ключей. Злоумышленник может с легкостью перепробовать все 26 ва-
риантов сдвига и найти тот, который позволяет получить членораздельный текст.
Шифр Виженера устраняет подобный недостаток, используя разную длину сдви-
га для разных букв в сообщении.

В шифре Виженера ключевое слово обозначает сдвиги для разных букв в сооб-
щении. Каждый символ в ключевом слове указывает сдвиг исходя из своей пози-
ции в алфавите. A означает нулевой сдвиг, B — сдвиг на одну позицию и т. д.

Чтобы расшифровать сообщение, открытый текст вставляется снизу от ключе-
вого слова, которое повторяется, пока не достигнет длины сообщения. На рисун-
ке 16.5 показан текст, записанный снизу от повторяющегося несколько раз клю-
чевого слова ZEBRAS.

Z E B R A S Z E B R A S Z E B R A S Z E
T H I S I S A S E C R E T M E S S A G E

Рис. 16.5. В шифре Виженера ключевое слово записывается сверху от открытого текста,
повторяясь необходимое количество раз

Теперь с помощью соответствующих букв можно создать шифрограмму. На-
пример, ключевая буква Z обозначает сдвиг 25, поэтому буква открытого текста T
превращается в S.

Чтобы упростить процесс сдвига, можно использовать «таблицу умножения»
по примеру той, которая показана на рисунке 16.6. Для кодирования буквы откры-
того текста T с буквой ключа Z нужно найти строку T и столбец Z.

		Буква ключа -------------->
Б	  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
у	A A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
к	B B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
в	C C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
а	D D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
	E E F G H I J K L M N O P Q R S T U V W X Y Z A B C D
с	F F G H I J K L M N O P Q R S T U V W X Y Z A B C D E
о	G G H I J K L M N O P Q R S T U V W X Y Z A B C D E F
о	H H I J K L M N O P Q R S T U V W X Y Z A B C D E F G
б	I I J K L M N O P Q R S T U V W X Y Z A B C D E F G H
щ	J J K L M N O P Q R S T U V W X Y Z A B C D E F G H I
е	K K L M N O P Q R S T U V W X Y Z A B C D E F G H I J
н	L L M N O P Q R S T U V W X Y Z A B C D E F G H I J K
и	M M N O P Q R S T U V W X Y Z A B C D E F G H I J K L
я	N N O P Q R S T U V W X Y Z A B C D E F G H I J K L M
	O O P Q R S T U V W X Y Z A B C D E F G H I J K L M N
|	P P Q R S T U V W X Y Z A B C D E F G H I J K L M N O
|	Q Q R S T U V W X Y Z A B C D E F G H I J K L M N O P
|	R R S T U V W X Y Z A B C D E F G H I J K L M N O P Q
|	S S T U V W X Y Z A B C D E F G H I J K L M N O P Q R
|	T T U V W X Y Z A B C D E F G H I J K L M N O P Q R S
V	U U V W X Y Z A B C D E F G H I J K L M N O P Q R S T
	V V W X Y Z A B C D E F G H I J K L M N O P Q R S T V
	W W X Y Z A B C D E F G H I J K L M N O P Q R S T V W
	X X Y Z A B C D E F G H I J K L M N O P Q R S T V W X
	Y Y Z A B C D E F G H I J K L M N O P Q R S T V W X Y
	Z Z A B C D E F G H I J K L M N O P Q R S T V W X Y Z

Рис. 16.6. Приведенная таблица упрощает сдвиг букв в шифре Виженера

Чтобы расшифровать букву криптограммы, ее нужно искать в столбце буквы
ключа. Расшифрованный символ берется из строки.

Простой частотный анализ, с помощью которого можно взломать шифр Цезаря,
здесь не сработает, поскольку не все буквы имеют одинаковый сдвиг. Однако для
взлома можно воспользоваться частотой вхождения букв в криптограмму.

Допустим, ключевое слово имеет длину K. В этом случае каждая K-я буква (на-
пример, 1, K + 1, 2 ? K + 1 и т. д.) имеет один и тот же сдвиг. В открытом тексте эти
буквы могут отличаться, но их относительные частоты совпадают.

Процесс взлома начинается с попытки угадать длину ключа и поисков букв
с одинаковым сдвигом. Например, можно попробовать ключ длиной 2, проверив
буквы под номерами 2, 4, 6, 8 и т. д. Если мы угадали с длиной, частота букв долж-
на быть подобна той, что в обычном английском языке (или в языке, который вы
используете). В частности, несколько букв, которые соотносятся с символами от-
крытого текста (такими как E, S и T), должны встречаться намного чаще других,
таких как X и Q.

Если длина ключа не равна 2, частоты букв должны распределяться достаточно
равномерно — ни одна из них не должна встречаться намного чаще других. В этом
случае придется пробовать другую длину и повторять все заново.

Если вы найдете длину ключа, при которой частота распределения похожа на
ту, что существует в английском языке, вам нужно будет проверять отдельные ча-
стоты, как это делалось в подстановочном шифре Цезаря. Буква, которая встреча-
ется чаще других, скорее всего, представляет зашифрованную E.

Точно так же нужно проверить другие буквы с тем же сдвигом, чтобы опре-
делить, насколько они смещены на самом деле. В сущности, на данном этапе
происходит декодирование подстановочного шифра Цезаря для каждой бук-
вы в ключе.

Результатом должен стать сдвиг для каждого символа в ключевом слове. Взлом
этого шифра требует больше усилий, чем в предыдущем случае, но он все равно
возможен.

11.2.3. Простая подстановка
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 375)

В простом подстановочном шифре у каждой буквы есть фиксированная за-
мена. Например, вместо A можно подставить H, вместо B — J, вместо C — X и т. д.

В качестве ключа здесь выступает соответствие между буквами открытого тек-
ста и шифрограммы. Если в сообщении используются только буквы английского
алфавита (A–Z), число возможных соответствий будет равно 4,0?? 10 26 .

В том случае, когда вы шифруете и расшифровываете сообщения вручную, вам
необходимо записывать используемые соответствия.

Если в вашем распоряжении есть компьютер, можно попробовать воссоздать
соответствие с помощью генератора псевдослучайных чисел. Отправитель вы-
бирает число K и использует его для инициализации генератора, который затем
придает случайный характер буквам A–Z и создает соответствие. Значение K
становится ключом. Получатель выполняет те же шаги, инициализируя гене-
ратор случайных чисел и восстанавливая соответствие, которое использова-
лось отправителем.

Единственное число запомнить проще, чем соответствия для всех букв, но
в большинстве генераторов случайных чисел количество возможных внутренних
состояний куда меньше, чем 4,0 ? 10 26 . Например, если число, выбранное вами для
инициализации генератора, является целым и имеет знак, у ключа будет лишь око-
ло 2 млрд потенциальных значений. Это все равно много, однако компьютер спосо-
бен с легкостью их перебрать и найти число, которое дает членораздельный текст.

Чтобы немного упростить данный процесс, можно также использовать частот-
ность. Если в криптограмме больше всего встречается буква W, то это, скорее все-
го, зашифрованная E.

11.2.4. Схема одноразовых блокнотов
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 375)

Схема одноразовых блокнотов — это некая разновидность шифра Виженера,
в которой ключ имеет ту же длину, что и сообщение. Сдвиг присваивается каж-
дой букве отдельно, поэтому для его поиска нельзя использовать частотный ана-
лиз криптограммы.

Поскольку зашифрованные буквы могут быть сдвинуты как угодно, то и соот-
ветствовать им по всей вероятности могут любые символы в открытом тексте. Сле-
довательно, злоумышленник не имеет возможности извлечь какую-либо информа-
цию из криптограммы (если не считать длины сообщения; хотя вы можете скрыть
и ее, добавив в текст дополнительные буквы).

Если подходить к процессу вручную, отправитель и получатель должны иметь
по одному блокноту с одинаковым набором случайных букв. С помощью этих букв
отправитель шифрует сообщение, вычеркивая их после того, как они были использо-
ваны, и больше не прибегая к ним снова. Те же буквы применяются для расшифров-
ки сообщения получателем; после использования они точно так же вычеркиваются.

Поскольку каждая буква, в сущности, имеет свой собственный сдвиг, шифр
нельзя будет взломать до тех пор, пока у злоумышленника не окажется одна из ко-
пий одноразового блокнота.

Недостаток подобной схемы заключается в том, что отправитель и получатель
должны обладать идентичными копиями блокнота, а безопасная передача этих ко-
пий может оказаться такой же сложной, как и отправка самого сообщения. Когда-то
блокнотами обменивались при помощи курьеров. Если курьера перехватывали,
блокнот выбрасывался и вместо него высылался новый.

11.3. Блочные шифры
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 376)

В блочном шифре сообщение разбивается на блоки, которые затем отдельно
шифруются и объединяются в криптограмму.

Во многих блочных шифрах кодирование выполняется путем многократной
трансформации данных. Трансформация должна быть обратимой, чтобы поз-
же криптограмму можно было расшифровать. Разбиение текста на одинаковые
блоки позволяет предусмотреть изменения фрагментов определенной длины.

Полезное свойство блочных шифров заключается в том, что они позволяют
криптографическому программному обеспечению работать с относительно не-
большими фрагментами текста. Представьте, например, что вам нужно зашифро-
вать очень длинное сообщение размером, скажем, в несколько гигабайтов. Если ис-
пользовать шифр с перестановкой по столбцам, программе придется переходить
в разные участки сообщения в памяти. Это может привести к сбрасыванию дан-
ных в файл подкачки, что существенно замедлит работу.

Блочный шифр ведет себя иначе. Он может анализировать сообщение по частям,
которые легко помещаются в памяти. Даже если программе придется использовать
файл подкачки, каждый фрагмент сообщения будет загружаться в память всего
один раз.

В подразделах, представленных ниже, описываются наиболее распространен-
ные виды блочных шифров.

11.3.1. Подстановочно-перестановочные сети
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 377)

Шифр подстановочно-перестановочной сети совершает несколько череду-
ющихся раундов, состоящих из подстановочной и перестановочной стадий. Пред-
ставьте, что эти стадии выполняются автоматами, размещенными внутри блоков
двух видов: подстановочных (S-блоки) и перестановочных (P-блоки).

S-блок берет небольшой фрагмент текста и объединяет его с частью ключа, запу-
тывая тем самым конечный результат. Чтобы «замести следы» как можно сильнее,
измените один-единственный бит ключа — в идеале это должно привести к транс-
формации примерно половины итоговых битов. Например, если S-блок имеет дело
с 1 байтом, он способен применить операцию XOR, чтобы совместить первый бит
ключа с битами 1, 3, 4 и 7, взятыми из текста. В разных шаблонах могут соединять-
ся разные биты ключа и сообщения. Вы можете варьировать S-блоки для разных
частей текстового фрагмента.

P-блок меняет местами биты во всем фрагменте и отправляет их в разные
S-блоки. Например, бит 1 из первого S-блока может отправиться к биту 7 из сле-
дующего раунда в третьем S-блоке.

На рисунке 16.7 показан трехраундовый шифр подстановочно-перестановочной
сети. S-блоки S 1 –S 4 совмещают ключ с фрагментами сообщения (стоит отметить, что
в каждом раунде могут использоваться разные части ключа). Все P-блоки выпол-
няют одну и ту же перестановку, отправляя результат работы S-блоков в S-блоки
следующего раунда.

Чтобы расшифровать сообщение, нужно выполнить те же шаги, только в об-
ратном порядке. Криптограмма пропускается через перевернутые S-блоки, после
чего результаты поступают в перевернутый P-блок; все это повторяется необходи-
мое количество раундов.

Один из недостатков такого подхода заключается в том, что S- и P-блоки долж-
ны уметь работать в обратном направлении, чтобы сообщения можно было рас-
шифровывать. Кроме того, для шифрования и расшифровки нужен разный код,
что усложняет процесс написания, отладки и сопровождения программ.

	Открытый текст

	 S1 S2 S3 S4

		  P

	 S1 S2 S3 S4

		  P

	 S1 S2 S3 S4

	Криптограмма

Рис. 16.7. В шифре подстановочно-перестановочной сети стадии подстановки
и перестановки чередуются

11.3.2. Шифр Фейстеля
###########################(Стивенс Род - Алгоритмы. Теория и практическое применение
(Мировой компьютерный бестселлер) - 2016.pdf Страница 378)

В шифре Фейстеля, названном в честь криптографа Хорста Фейстеля, сообще-
ние разбивается пополам на левую и правую части — L 0 и R 0 . К правой части при-
меняется функция, и полученный результат совмещается с левой частью с помо-
щью операции XOR. Затем эти два фрагмента меняются местами и процесс повто-
ряется определенное количество раундов.

Высокоуровневое описание такого алгоритма показано в виде следующих шагов.
1. Разбиваем открытый текст пополам на два блока — L 0 и R 0 .
2. Повторяем:
a. присваиваем L i+1 = R i ;
b. присваиваем R i+1 = L i XOR F(R i , K i ).

K i — это подключ, который используется в раунде i (набор значений, сгенери-
рованных с помощью ключа сообщения). Например, проще всего было бы разбить
ключ на части и использовать их по порядку, повторяя при необходимости (это
похоже на шифр Виженера, который задействует каждую букву ключа для шиф-
рования одного символа из открытого текста и затем, если понадобится, повторя-
ет данные буквы).

После выполнения нужного количества раундов криптограмма будет иметь
вид L i + 1 + R i + 1 .

Чтобы расшифровать сообщение, нужно получить итоговые значения L i + 1
и R i + 1 , разделив криптограмму пополам. Если взглянуть на предыдущие шаги, мож-
но увидеть, что R i — это L i + 1 . Поскольку мы уже знаем, чему равно L i + 1 , значение
R i нам тоже известно.

Чтобы восстановить L i , заменим в уравнении, использованном на шаге 2b, L i + 1
на R i . Получим следующее:
R i + 1 = L i XOR F(R i , K i ) = L i XOR F(L i + 1 , K i ).

На данном этапе нам уже известно значение L i + 1 , поэтому мы можем вычислить
F(L i + 1 , K i ). Если совместить это с R i + 1 , условия F(L i + 1 , K i ) нивелируются.
В резуль-
тате остается только восстановленное значение L i .

Алгоритм расшифровывания описан в виде следующих шагов.
1. Разделяем криптограмму пополам, на L i + 1 и R i + 1 .
2. Повторяем:
a. присваиваем R i = L i + 1 ;
b. присваиваем L i = R i + 1 XOR F(L i + 1 , K i ).

Одним из преимуществ шифров Фейстеля является то, что расшифровывание
не требует инвертировать функцию F. Это означает, функция F может быть любой,
даже такой, которую сложно обратить в противоположную сторону.

Еще одно преимущество шифров Фейстеля заключается в том, что процессы
шифрования и расшифровывания практически совпадают. Отличается только по-
рядок использования подключей. Это означает, что для шифрования и расшифро-
вывания нужен всего лишь один фрагмент кода.

11.4. Примеры шифрования используемые в мире ИТ
###########################(https://ru.wikipedia.org/wiki/Шифрование)
Шифрование применяется для хранения важной информации в ненадёжных источниках и передачи
её по незащищённым каналам связи. Такая передача данных представляет из себя два взаимно
обратных процесса:

 - Перед отправлением данных по линии связи или перед помещением на хранение они
подвергаются зашифровыванию.
 - Для восстановления исходных данных из зашифрованных к ним применяется процедура
расшифровывания.

Шифром называется пара алгоритмов, реализующих каждое из указанных преобразований. Эти
алгоритмы применяются к данным с использованием ключа. Ключи для шифрования и для
расшифровывания могут различаться, а могут быть одинаковыми. Секретность второго
(расшифровывающего) из них делает данные недоступными для несанкционированного
ознакомления, а секретность первого (шифрующего) делает невозможным внесение ложных
данных. В первых методах шифрования использовались одинаковые ключи, однако в 1976 году
были открыты алгоритмы с применением разных ключей. Сохранение этих ключей в секретности и
правильное их разделение между адресатами является очень важной задачей с точки зрения
сохранения конфиденциальности передаваемой информации. Эта задача исследуется в теории
управления ключами (в некоторых источниках она упоминается как разделение секрета).

В настоящий момент существует огромное количество методов шифрования. Главным образом эти
методы делятся, в зависимости от структуры используемых ключей, на симметричные методы и
асимметричные методы. Кроме того, методы шифрования могут обладать различной
криптостойкостью и по-разному обрабатывать входные данные — блочные шифры и поточные
шифры. Всеми этими методами, их созданием и анализом занимается наука криптография.

11.4.1. AES
###########################(https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard)

Advanced Encryption Standard (AES), также известный как Rijndael (произносится [rɛindaːl]
(Рэндал[1])) — симметричный алгоритм блочного шифрования (размер блока 128 бит, ключ
128/192/256 бит), принятый в качестве стандарта шифрования правительством США по
результатам конкурса AES. Этот алгоритм хорошо проанализирован и сейчас широко
используется, как это было с его предшественником DES. Национальный институт стандартов и
технологий США (англ. National Institute of Standards and Technology, NIST) опубликовал
спецификацию AES 26 ноября 2001 года после пятилетнего периода, в ходе которого были
созданы и оценены 15 кандидатур. 26 мая 2002 года AES был объявлен стандартом шифрования.
По состоянию на 2009 год AES является одним из самых распространённых алгоритмов
симметричного шифрования[2][3]. Поддержка AES (и только его) введена фирмой Intel в
семейство процессоров x86 начиная с Intel Core i7-980X Extreme Edition, а затем на
процессорах Sandy Bridge.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.2. RSA
###########################(https://ru.wikipedia.org/wiki/RSA)

RSA (аббревиатура от фамилий Rivest, Shamir и Adleman) — криптографический алгоритм с
открытым ключом, основывающийся на вычислительной сложности задачи факторизации больших
целых чисел.

Криптосистема RSA стала первой системой, пригодной и для шифрования, и для цифровой
подписи. Алгоритм используется в большом числе криптографических приложений, включая PGP,
S/MIME, TLS/SSL, IPSEC/IKE и других.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.3. MD5
###########################(https://ru.wikipedia.org/wiki/MD5)

MD5 (англ. Message Digest 5) — 128-битный алгоритм хеширования, разработанный профессором
Рональдом Л. Ривестом из Массачусетского технологического института (Massachusetts
Institute of Technology, MIT) в 1991 году. Предназначен для создания «отпечатков» или
дайджестов сообщения произвольной длины и последующей проверки их подлинности. Широко
применялся для проверки целостности информации и хранения хешей паролей.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.4. SHA-1
###########################(https://ru.wikipedia.org/wiki/SHA-1)

Secure Hash Algorithm 1 — алгоритм криптографического хеширования. Описан в RFC 3174. Для
входного сообщения произвольной длины (максимум {\displaystyle 2^{64}-1} 2^{64}-1 бит, что
примерно равно 2 эксабайта) алгоритм генерирует 160-битное (20 байт) хеш-значение,
называемое также дайджестом сообщения, которое обычно отображается как шестнадцатиричное
число, длиной в 40 цифр. Используется во многих криптографических приложениях и
протоколах. Также рекомендован в качестве основного для государственных учреждений в США.
Принципы, положенные в основу SHA-1, аналогичны тем, которые использовались Рональдом
Ривестом при проектировании MD4.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.5. SHA-2
###########################(https://ru.wikipedia.org/wiki/SHA-2)

SHA-2 (англ. Secure Hash Algorithm Version 2 — безопасный алгоритм хеширования, версия 2)
— семейство криптографических алгоритмов — однонаправленных хеш-функций, включающее в себя
алгоритмы SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/256 и SHA-512/224.

Хеш-функции предназначены для создания «отпечатков» или «дайджестов» для сообщений
произвольной длины. Применяются в различных приложениях или компонентах, связанных с
защитой информации.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.6. SSL
###########################(https://ru.wikipedia.org/wiki/SSL)

SSL (англ. Secure Sockets Layer — уровень защищённых cокетов) — криптографический
протокол, который подразумевает более безопасную связь. Он использует асимметричную
криптографию для аутентификации ключей обмена, симметричное шифрование для сохранения
конфиденциальности, коды аутентификации сообщений для целостности сообщений. Протокол
широко использовался для обмена мгновенными сообщениями и передачи голоса через IP (англ.
Voice over IP — VoIP) в таких приложениях, как электронная почта, интернет-факс и др. В
2014 году правительство США сообщило об уязвимости в текущей версии протокола[1]. SSL
должен быть исключён из работы в пользу TLS (см. CVE-2014-3566).

SSL изначально разработан компанией Netscape Communications для добавления протокола HTTPS
в свой веб-браузер Netscape Navigator. Впоследствии на основании протокола SSL 3.0 был
разработан и принят стандарт RFC, получивший имя TLS.

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)

11.4.7. TLS
###########################(https://ru.wikipedia.org/wiki/TLS)

TLS (англ. transport layer security — Протокол защиты транспортного уровня[1]), как и его
предшественник SSL (англ. secure sockets layer — слой защищённых сокетов), —
криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети
Интернет[2]. TLS и SSL используют асимметричное шифрование для аутентификации,
симметричное шифрование для конфиденциальности и коды аутентичности сообщений для
сохранения целостности сообщений.

Данный протокол широко используется в приложениях, работающих с сетью Интернет, таких как
веб-браузеры, работа с электронной почтой, обмен мгновенными сообщениями и IP-телефония
(VoIP).

TLS-протокол основан на спецификации протокола SSL версии 3.0, разработанной компанией
Netscape Communications[3]. Сейчас развитием стандарта TLS занимается IETF. Последнее
обновление протокола было в RFC 5246 (август 2008) и RFC 6176 (март 2011).

(Приводить алгоритм шифрования не вижу смысла, т.к. слишком объёмен и сложен.)
