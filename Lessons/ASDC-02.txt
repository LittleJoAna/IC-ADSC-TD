2. Знакомство
	2.1. Понимание алгоритма(немного истории-аль-Хорезми)
		2.1.1. Свойства алгоритмов
		2.1.2. Способы записи алгоритмов
	2.2. Понимание структур данных
		2.2.1. Элементы динамического множества(структур данных)
		2.2.2. Операции над динамическими множествами(структурами данных)
	2.3. Cтpyктypы данных
		2.3.1. Массивы
		2.3.2. Графы
		2.3.3. Хеш-таблицы
	2.4. Инструменты визуализации алгоритмов и структур данных
		2.4.1. Draw.io
		2.4.2. Umbrello
		2.4.3. Eclipse + Papyrus

2. Знакомство
###########################(Wikipedia https://ru.wikipedia.org/wiki/Алгоритм)
Алгоритм - набор инструкций, описывающих порядок действий исполнителя для достижения
некоторого результата.

2.1. Понимание алгоритма(немного истории-аль-Хорезми)
###########################(Wikipedia https://ru.wikipedia.org/wiki/Алгоритм)

Само слово «алгоритм» происходит от имени хорезмского учёного аль-Хорезми. Около 825 года
он написал сочинение Китаб аль-джебр валь-мукабала («Книга о сложении и вычитании»), из
оригинального названия которого происходит слово «алгебра» (аль-джебр — восполнение). В
этой книге впервые дал описание придуманной в Индии позиционной десятичной системы
счисления. Персидский оригинал книги не сохранился. Аль-Хорезми сформулировал правила
вычислений в новой системе и, вероятно, впервые использовал цифру 0 для обозначения
пропущенной позиции в записи числа (её индийское название арабы перевели как as-sifr или
просто sifr, отсюда такие слова, как «цифра» и «шифр»). Приблизительно в это же время
индийские цифры начали применять и другие арабские учёные.

2.1.1. Свойства алгоритмов
###########################(Wikipedia https://ru.wikipedia.org/wiki/Алгоритм)

Различные определения алгоритма в явной или неявной форме содержат следующий ряд общих
требований:

1. Дискретность — алгоритм должен представлять процесс решения задачи как последовательное
выполнение некоторых простых шагов. При этом для выполнения каждого шага алгоритма
требуется конечный отрезок времени, то есть преобразование исходных данных в результат
осуществляется во времени дискретно.

2. Детерминированность (определённость). В каждый момент времени следующий шаг работы
однозначно определяется состоянием системы. Таким образом, алгоритм выдаёт один и тот же
результат (ответ) для одних и тех же исходных данных.

2. Понятность — алгоритм должен включать только те команды, которые доступны исполнителю и
входят в его систему команд.

3. Завершаемость (конечность) — в более узком понимании алгоритма как математической
функции, при правильно заданных начальных данных алгоритм должен завершать работу и
выдавать результат за определённое число шагов.

4. Массовость (универсальность). Алгоритм должен быть применим к разным наборам начальных
данных.

5. Результативность — завершение алгоритма определёнными результатами.

2.1.2. Способы записи алгоритмов
###########################(https://studfiles.net/preview/1755574/)

1. Словесная запись алгоритма. Словесная форма используется обычно для описания
алгоритмов, предназначенных исполнителю – человеку. Команды записываются на обычном языке
и выполняются по порядку. В командах могут использоваться формулы, специальные
обозначения, но каждая команда должна быть понятна исполнителю. Естественный порядок
команд может быть нарушен (если требуется, например, переход к предыдущей команде или
требуется обойти очередную команду при каком-то условии), в этом случае команды можно
нумеровать и указывать команду, к которой требуется перейти. Например, перейти к п.3 или
повторить с п.4.

Пример:(стоит поменять, т.к. плагиат с сайта -
http://fb.ru/article/283912/vidyi-algoritmov-v-informatike-primeryi. Этот же пример
используется в 4 уроке, в разделе 4.1. Если менять, то их нужно будет синхронизировать
для сохранения общей нити повествования.)
1. Встаем, когда звенит будильник.
2. Умываемся.
3. Чистим зубы.
4. Делаем зарядку.
5. Одеваемся.
6. Кушаем.
7. Обуваемся и идем в школу.
8. Конец алгоритма.

2. Графическая форма. Алгоритмы представляются в виде блок-схем. Существуют специальные
стандарты для построения блок-схем, где определяются графические изображения блоков.
Команды алгоритмов записываются внутри блоков на обычном языке или с использованием
математических формул. Блоки соединяются по определенным правилам линиями связи, которые
показывают порядок выполнения команд.

Пример:(https://studfiles.net/preview/1755574/page:2/)
(Врядли стоит указывать правила составления блок-схем находящиеся по ссылке, но пример
блок-схемы и картинки элементов блок-схемы добавить стоит. С использованием алгоритма
описанного выше в словесной форме.)

3. На языке программирования. Если алгоритм разработан для решения задачи на ЭВМ, то для
того, чтобы он мог выполниться исполнителем – ЭВМ, его необходимо записать на языке,
понятном этому исполнителю. Для этого разработано множество языков программирования для
решения задач разных классов. Запись алгоритма на языке программирования называется
программой.

Примеры будут рассмотрены в 4ом уроке, на примерах:
 - Алгоритм Эвклида
 - Ускоренный алгоритм Эвклида
 - Решето Эратосфена


2.2. Понимание структур данных
###########################(Wikipedia https://ru.wikipedia.org/wiki/Структура_данных)
Структура данных (англ. data structure) — программная единица, позволяющая хранить и
обрабатывать множество однотипных и/или логически связанных данных в вычислительной
технике. Для добавления, поиска, изменения и удаления данных структура данных
предоставляет некоторый набор функций, составляющих её интерфейс.

2.2.1. Элементы динамического множества(структур данных)
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu. Страница 260)

В типичных реализациях динамического множества каждый его элемент представлен некоторым
объектом; если в нашем распоряжении имеется указатель на объект, то можно проверять и
изменять значения его атрибутов. В динамических множествах некоторых типов
предпологается, что один из атрибутов объекта идентифицирует ключ (key). Если все ключи
различны, то динамическое множество представимо в виде множества ключевых значений.
Объекты могут содержать сопутствующие данные (satellite data), которые находятся в других
его атрибутах, но не используются реализацией множества. Кроме того, объект может
содержать атрибуты, доступные для манипуляций во время выполнения операций над
множеством; иногда в этих атрибутах могут храниться данные или указатели на другие
объекты множества.

В некоторых динамических множествах предпологается, что их ключи являются членами
полностью упорядоченного множества, например множества действительных чисел или множества
всех слов, которые могут быть расположены в алфавитном порядке. Полное упорядочение,
например, позволяет определить минимальный элемент множества или говорить о ближайшем
элементе множества, превышающем заданный.

2.2.2. Операции над динамическими множествами(структурами данных)
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu. Страница 261)

Операции над динамическим множеством можно разбить на две категории:
 - запросы(queries), которые просто возвращают информацию о множестве
 - модифицирующие операции(modifying operations), изменяющие множество.

Ниже приведен список типичных операций. В каждом конкретном приложении требуется, чтобы
были реализованы лишь некоторые из них:

- Search(S, k) - запрос, который возвращает указатель на элемент x заданного множества
S, для которого x.key = k, или значение NIL(NULL?), если в множестве S такой элемент
отсутствует.

- Insert(S, x) - модифицирующая операция, которая пополняет заданное множество S одним
элементом, на который указывает x. Обычно предпологается, что выполнена предварительная
инициализация всех атрибутов элемента x, требующихся реализации множества.

- Delete(S, x) - модифицирующая операция, удаляющая из заданного множества S элемент, на
который указывает x. (Обратите внимание, что в этой операции используется указатель на
элемент, а не его ключевое значение.)

- Minimum(S) - запрос к полностью упорядоченному множеству S, который возвращает
указатель на элемент этого множества с наименьшим ключом.

- Maximum(S) - запрос к полностью упорядоченному множеству S, который возвращает
указатель на элемент этого множества с наибольшим ключом.

- Successor(S, x) - запрос к полностью упорядоченному множеству S, который возвращает
указатель на элемент множества S, ключ которого является ближайшим соседом ключа элемента
x и превышает его. Если же x - максимальный элемент множества S, то возвращается значение
NIL(NULL?).

- Predecessor(S, x) - запрос к полностью упорядоченному множеству S, который возвращает
указатель на элемент множества S, ключ которого является ближайшим меньшим по значению
соседом ключа элемента x. Если же x - минимальный элемент множества S, то возвращается
значение NIL(NULL?).

2.3. Cтpyктypы данных

2.3.1. Массивы
###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 210)

Массив это не просто структура данных; это также механизм языка, который позволяет
адресовать множество подобных объектов в простом uикле. Массивы заслуживают пристальноrо
изучения по той причине, что принuипы работь с ними могyт быть использованы для
реализаuии любой классической структуры данных.

(Примеров очень много в книге, с разными типами массивов, выбрать что-то конкретное
сложно. При необходимости все листинги есть. Можно будет выбрать.)

2.3.2. Графы
###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 372)

Графы предоставляют программистам очень полезные инструменты. Это мощная абстракция,
описывающая множество реальных проблем, которые очень тpyдно или вообще невозможно
смоделировать иначе. Транспортные системы, компьютерные сети и World Wide Web - это лишь
небольшое количество реальных систем, которые легко можно представить в форме графов.
В этой главе описываются некоторые простые элементы теории гpафов, рассматриваются
приложения, к которым ее можно применить, а также вопросы реализации и использования этой
теории на практике.

Графы - это просто коллекция (набор) точек (вершин), которые соединяются между собоЙ
ребрами. Когда две вершины соединяются ребром, говорят, что это смежные вершины. Графы
обычно лучше, чем полная абстракция, представляют объекты, поскольку ребра и вepшины
имеют вполне реальные аналоги. Например, можно сказать, что каждая вершина - это
железнодорожная станция, а ребра - железнодорожные пути между станциями.

Более формально граф определяется как набор вepшин V и ребер Е, которые составляют сам
гpаф. Каждое ребро определяется парой смежных вершин (v,w), где v и w являются элементами
множества V вершин.

Ребра могyт также иметь приписываемые им издержки (или затраты, или веса). Это числовое
значение, зависяшее от тoгo, насколько "трудно" передвигаться по ребру. Такое значение
может характеризовать время, расстояние, затраты или какие-либо другие параметры,
которые могyт быть выражены числом. Подобные знaчения используются, когда осуществляется
выбор оптимального маршрута от одной вершины до другой.

"Степень вершины" - это число выходящих из нее peбер. Полустепенью захода вершины
считается количество трактов, входящих в вершину. Данные значения являются основой
некоторых алгоритмов, которые будут рассматриваться в настояшей главе далее.

"Подграф" - это граф, сформированный из некоторых вершин и ребер другого гpафа. В подграфе
могут быть представлены только вершины и ребра, представленные в оригинальном гpафе.
Любое подмножество вершин и ребер гpaфа G является подгpафом G.

"Путь" представляет собой последовательность вepшин, которая описывает маршрут вдоль ребер
между вершинами гpафа. Под издержками пути понимается сумма издержек пройденных на этом
пути ребер.

Граф представляет реальную информацию. Сам гpаф - это абстракция чего-то реального:
вершины и ребра могут выступать в качестве реальных объектов или coстояний. Все, что
включает дискретные состояния с соединениями между ними, может быть представлено в форме
гpафа.

Обычно легко обнаружить сходство некоей системы с гpафом. И дорожные карты, и
компьютерные сети, и электронные схемы соединений - все они имеют графоподобные свойства.
Основное правило заключается следующем: если что-то похоже на граф, значит, это и есть
граф!

(Примеров очень много в книге, с разными типами графов, выбрать что-то конкретное
сложно. При необходимости все листинги есть. Можно будет выбрать.)

2.3.3. Хеш-таблицы
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf. Страница 487)

Хеш­-таблицей называется структура данных, обеспечивающая очень быструю вставку и поиск.
На первый взгляд звучит слишком хорошо, чтобы быть правдой: независимо от количества
элементов данных вставка и поиск (а иногда и удаление) выполняются за время, близкое к
постоянному: O(1) в O-синтаксисе. На практике это лишь несколько машинных команд.

Для пользователя хеш-таблицы обращение к данным происходит практически мгновенно. Все
делается настолько быстро, что компьютерные программы часто используют хеш-таблицы при
необходимости сделать выборку из десятков тысяч элементов менее чем за секунду (как,
например, в системах проверки орфографии).

Хеш-таблицы по скорости значительно превосходят деревья, которые выполняют операции за с
относительно малое время O(logN ). Операции с хеш-таблицами не только быстро выполняются,
но и относительно просто программируются.

У хеш-таблиц также имеются свои недостатки. Они реализуются на базе массивов, а массивы
трудно расширить после создания. У некоторых разновидностей хеш-таблиц быстродействие
катастрофически падает при заполнении таблицы, поэтому программист должен довольно точно
представлять, сколько элементов данных будет храниться в таблице (или приготовиться к
периодическому перемещению данных в другую хеш-таблицу большего размера — процесс
занимает довольно много времени).

Кроме того, при работе с хеш-таблицами не существует удобного способа перебора элементов в
определенном порядке (скажем, от меньших к большим). Если вам необходима такая
возможность, поищите другую структуру данных.

Но если вам не требуется перебирать элементы в определенном порядке, а размер базы данных
можно спрогнозировать заранее, хеш-таблицы не имеют себе равных по скорости и удобству.

Листинги в папке Listings.
hash.java (На Си у Лафоре примеров нет. Более внятного примера на Си не нашёл. За
исключением Стивенс Р. - Алгоритмы. Теория и практическое применение (Мировой компьютерный
бестселлер) - 2016.pdf, но там примеры на C# и довольно объёмные.)

2.4. Инструменты визуализации алгоритмов и структур данных
###########################(https://habr.com/post/227915/)
Визуализация использует зрительную систему человека, чтобы расширить человеческий
интеллект: с её помощью мы лучше понимаем важные абстрактные процессы и другие вещи тоже.

Проще говоря, зрение помогает нам думать.

Более того, если кто-то хочет сам разобраться в работе того или иного алгоритма, то лучше
всего попробовать сделать визуализацию самому, потому что попытка объяснить нечто — это
лучший способ разобраться в предмете.

К тому же, графическое представление проблемы помогает найти ошибки в своей реализации
алгоритма, да и вообще, это интересно само по себе.

2.4.1. Draw.io
###########################(http://koptelov.info/draw-io/)
Draw.io  это инструмент для создания диаграмм и блок-схем онлайн. При этом огромное число
шаблонов, которые позволяют нарисовать все что душе угодно. Онлайн сервис Draw.io —
совершенно бесплатный, и главное не требует регистрации. Также доступна оффлайн версия
для различных операционных систем.

Сайт - https://www.draw.io
Видеопрезентация(англ.) - https://www.youtube.com/watch?v=Z0D96ZikMkc

2.4.2. Umbrello
###########################(https://ru.wikipedia.org/wiki/Umbrello)
Umbrello — среда UML-моделирования. Это приложение является свободным программным
обеспечением, предназначенным для построения UML диаграмм на разных операционных
системах. Является CASE инструментом.

Сайт - https://umbrello.kde.org
Скриншоты - https://umbrello.kde.org/screenshots.php

2.4.3. Eclipse + Papyrus
###########################(https://en.wikipedia.org/wiki/Papyrus_(software))
Papyrus это среда UML-моделирования с открытым исходным кодом основанная на платформе
Eclipse.

Сайт - https://www.eclipse.org/papyrus/
Видеопрезентация(англ.) - https://www.youtube.com/watch?v=qaypKeO5AUk
