7. Стеки, очереди и списки
	7.1. Стеки и очереди
		7.1.1. Стеки
			7.1.1.1. Создание стека с использованием массива
		7.1.2. Очереди
			7.1.2.1. Реализация очереди через массив
		7.1.3. Очереди по приоритету
		7.1.4. Двусторонние очереди (деки)
			7.1.4.1. Реализация двухсторонней очереди
	7.2. Динамические структуры данных
	7.3. Списки
		7.3.1. Односвязные списки
		7.3.2. Двусвязные списки
			7.3.2.1. Стек на основе односвязного списка
		7.3.3. Циклические списки

7. Стеки, очереди и списки
7.1. Стеки и очереди
7.1.1. Стеки
###########################(Из методички 5.)
Стек — это структура данных, которая работает по принципу «первый пришёл — последний ушел»
(First In — Last Out). Стек удобно использовать в некоторых алгоритмах, поэтому полезно
уметь создавать эту структуру. Рассмотрим создание стека на основе массива.

Типовые операции:
1. Push — добавление в стек.
2. Pop​ — изъять из стека.
3. Проверка наличия элементов.
4. Очистка.

7.1.1.1. Создание стека с использованием массива
###########################(Из методички 5.)
В примере создадим одномерный массив из 1000 элементов (максимальный размер стека).
Глобальная переменная N является одновременно и количеством элементов, и «указателем» на
последний элемент в массиве. Указателем в переносном смысле: просто с помощью N можно
узнать, какой элемент лежит на вершине стека.

(Картинка примера в методичке)

Обратите внимание на строчку:

#define​ T ​char

Мы определяем некоторый тип в качестве T и пишем программу, используя его как тип стека.
Если нам нужно будет изменить тип стека, достаточно изменить его тип в директиве
компилятора.

#include <stdio.h>

#define T char
#define MaxN 1000

T Stack[MaxN];

int N = -1;

void push(T i)
{
	if (N < MaxN)
	{
		N++;
		Stack[N] = i;
	}
	else
		printf("Stack overflow");
}

T pop()
{
	if (N != -1)
		return Stack[N--];
	else
		printf("Stack is empty");
}

int main(int argc, char *argv[])
{
	T c;
	push('a');
	push('b');
	push('c');
	push('d');
	push('e');
	push('f');

	while(N != -1)
		printf("%c", pop());

	return 0;
}

Средства языка С позволяют создать структуру Stack (struct Stack), которая хранит как сами
элементы, так и их количество. Благодаря этому можно создавать любое количество стеков.

###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 247)

По своей внутренней природе, стек - это просто список, но список, который подчиняется
двум правилам. Первое правило заключается в том, что новые элементы можно помещать только
на вершину стека; это называется занесением (pushiпg) элемента. Второе правило состоит в
том, что вы можете брать элементы только с вершины стека; это называется извлечением
(poppiпg). В краткой форме эти правила содержатся в акрониме(сокращении) LIFO (Last In,
Fiгst Out - последним пришел, первым ушел).

Листинги в папке Listings.
sllist.c
sllist.h
stack.c
stack.h
stackmn.c
strarr.c
strarr.h

7.1.2. Очереди
###########################(Из методички 5.)
Очередь ​​— структура данных, также организованная по принципу FIFO (First In — First
Out). Это линейный список, для которого введены две операции:
1. Добавление нового элемента в конец очереди.
2. Удаление первого элемента из очереди.

Операционные системы используют очереди для организации сообщений между программами:
каждая программа имеет свою очередь сообщений. Контроллеры жестких дисков формируют
очереди запросов ввода и вывода данных. В сетевых маршрутизаторах создается очередь из
пакетов данных, ожидающих отправки.

Типовые операции:
1. Enqueue — добавление в очередь.
2. Dequeue​ — изъятие из очереди.
3. Проверка наличия элементов.
4. Очистка.

7.1.2.1. Реализация очереди через массив
###########################(Из методички 5.)
В этой реализации мы создаем массив q[n], который будет определять размер очереди.

(Картинка примера в методичке)

Переменная front указывает на голову очереди, а rear — на элемент, который заполнится
(конец очереди), когда в очередь добавляется новый элемент. При добавлении нового
элемента он записывается в очередь в q[rear], а rear увеличивается на единицу. Если
значение rear становится больше n, то мы как бы циклически обходим массив, и значение
переменной становится равным 0. Извлечение элемента из очереди производится аналогично:
после извлечения элемента q[front] из очереди переменная front увеличивается на 1. Если
значение front становится больше n, то мы как бы циклически обходим массив, и значение
переменной становится равным 0.

(Примера в коде нет.)

###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 253)

В основных чертах очереди похожи на стеки, но подчиняются другому набору правил,
известному как FIFO (First in, First Out - первым пришёл, первым ушёл). При таком режиме
можно добавлять элементы только в конец очереди и удалять элементы только из начала
очереди. Эта очередь функционирует точно так же, как и обычная очередь в магазине или на
почте.

Листинги в папке Listings.
queue.c
queue.h
queuemn.c
sllist.c
sllist.h

7.1.3. Очереди по приоритету
###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 255)

Очередь по приоритету - это структура данных, которая облегчает хранение элементов данных
в порядке приоритета. Чаще вceгo они используются в приложениях планировки задач. Другой
сферой их применения являются многозадачные операционные системы. Они функционируют в
соответствии с очень простым правилом: первым пришел, наибольшим ушел (First In, Largest
Out) или, если хотите: первым пришел, наименьшим ушел (First In, Smallest Out) - все
зависит от тoгo, как вы определяете приоритет.

Листинги в папке Listings.
heap.c
heap.h
heapmn.c

7.1.4. Двусторонние очереди (деки)
###########################(Из методички 5.)
Дек (двухсторонняя очередь) — линейный список, в котором можно добавлять и удалять
элементы как с одного, так и с другого конца.

Из этого определения следует, что дек может работать и как стек, и как очередь. С помощью
дека можно, например, моделировать колоду игральных карт.

Типовые операции:
1. pushBack — добавление в конец очереди.
2. pushFront — добавление в начало очереди.
3. popBack — выборка с конца очереди.
4. popFront — выборка с начала очереди.
5. Проверка наличия элементов.
6. Очистка.

7.1.4.1. Реализация двухсторонней очереди
###########################(Из методички 5.)
Для реализации двухсторонней очереди можно прибегнуть к разным алгоритмам:
1. Реализовать за счёт использования структуры стек, в котором можно добавлять и удалять
элементы с обоих концов. Правда, в этом случае лучше использовать динамические структуры
данных (см. далее).
2. Реализовать за счёт использования очереди, в которой также можно добавлять и удалять
данные с обоих концов.
3. Реализовать за счет статического массива, данные в котором будут сдвигаться при
добавлении элементов.
4. Использовать динамический двусвязный список (см. далее)

(Примера в коде нет.)

###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 260)

Слово deque (произносится "дек") - это довольно симпатичный неологизм в программировании;
он происходит от выражения doubIe-ended queue (двусторонняя очередь), точно описывающего
свой смысл. Устоявшегося акронима (сокращения), описываюшего принцип действия деков и
подобного тем, что имеются для стеков и очередей, нет. Самое лучшее, что подходит, -
это FOLIFOLO (First or Last In, First or Last Out - первым или последним пришел, первым
или последним ушел). Как бы там ни было, правила просты: можно добавлять и удалять
элементы с любой стороны дека, но нельзя добавлять или удалять элементы в любом другом
месте дека.

Листинги в папке Listings.
deque.c
deque.h
dequemn.c
dllist.c
dllist.h

7.2. Динамические структуры данных
###########################(Из методички 5.)
Довольно часто нужно решать задачи, в которых заранее неизвестно, сколько элементов данных
будет использовано. Например, мы создавали с вами стек большего размера, чем он мог
реально понадобиться.

Частично мы можем решить эту проблему с помощью динамических массивов, но и в этом случае
нам нужно заранее знать, сколько элементов будет в массиве. Можно создавать каждый раз
новый массив, увеличивая или уменьшая его размер, но тогда нужно будет копировать все
элементы из старого массива в новый.

Когда количество элементов заранее неизвестно, используют динамические структуры данных.

7.3. Списки
7.3.1. Односвязные списки
###########################(Из методички 5.)
В односвязном списке каждый элемент информации содержит ссылку на следующий элемент
списка. Каждый элемент данных обычно представляет собой структуру, которая состоит из
информационных полей и указателя связи.

Односвязный список из трёх элементов:
(Картинка примера в методичке)

В односвязном списке используется структура, которая содержит данные и
переменную-указатель.

struct​ ​TNode
{
	​int​ value​;​ ​// Данные
	​struct​ ​TNode​*​ ​next​;​ ​// Указатель на следующий элемент списка
};
struct​ ​TNode​*​ ​Head=NULL;

###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 227)

Односвязный список - это способ соединения объектов таким образом, кoгда каждый объект
указывает на следующий объект в этом списке. Порядок расположения объектов зависит от
приложения, и обычно это просто порядок, в котором программа встречает данные.
Списки особенно полезны тoгдa, кoгдa порядок элементов в них не играет роли. Если
требуется упорядочить список по некоторому ключу так, чтобы можно было осуществлять в нем
поиск отдельного элемента, то лучше использовать более упорядоченную структуру дaнных,
такую как динамически распределяемая область памяти или дерево.

Списки особенно полезны в тех случаях, кoгдa дaнные в памяти необходимо запоминать сразу
же, а мы заранее не знаем, сколько данных можем получить, или кoгдa требуется переставлять
данные произвольным образом.

Листинги в папке Listings.
sllist.c
sllist.h
sllistmn.c

7.3.2. Двусвязные списки
###########################(Из методички 5.)
Поскольку элементы односвязного списка содержат ссылки только на следующий элемент, к
предыдущему перейти нельзя. Поэтому перебор возможен только в одном направлении. Этот
недостаток устранён в двусвязном списке, где каждый элемент хранит адрес как следующего,
так и предыдущего элемента.

(Картинка примера в методичке)

Для такого списка обычно хранят два адреса: «голова» списка (указатель head) и его «хвост»
(указатель tail).

struct​ ​TNode
{
	​int​ value​;​ ​// Данные
	​struct​ ​TNode​ ​*​next​;​ ​// Указатель на следующий элемент списка
	​struct​ ​TNode​ ​*​prev​;​ ​// Указатель на предыдущий элемент списка
};
struct​ ​TNode​ ​*​head;
struct​ ​TNode​ ​*​tail;

Рассмотрим пример создания стека на основе динамической структуры «односвязный список».

7.3.2.1. Стек на основе односвязного списка
###########################(Из методички 5.)
Создадим стек на основе односвязного списка.

Напомним, что стек представляет собой специально организованный по принципу First In —
Last Out («первым пришёл — последним ушёл») вид памяти. Для организации стека достаточно
создать односвязный список и реализовать две команды: добавления на вершину списка (Push)
и извлечения с вершины списка (Pop). Так как в односвязном списке мы должны хранить его
вершину, мы легко реализуем эти две команды.

Для работы с динамическими структурами данных создадим узел этих данных:

struct​ ​TNode
{
	​int​ value​;​ ​// Данные
	​struct​ ​TNode​ ​*​next​;​ ​// Указатель на следующий элемент списка
};

Самым трудным для понимания здесь является то, что внутри структуры Node мы создаём
указатель на самих себя.

Чтобы не писать в программе struct TNode, дадим этой структуре имя Node:

typedef​ ​struct​ ​TNode​ ​Node;


Структура Stack

Опишем структуру Stack и глобальную переменную Stack. Это позволит структурировать
программу, а также, при желании, даст возможность создавать несколько независимых стеков.

struct​ ​Stack
{
	​Node​ ​*​head;
	​int​ size;
	​int​ maxSize;
};
struct​ ​Stack​ ​Stack;

В главной программе в поля структуры Stack запишем максимальный размер стека и
инициализируем head пустой ссылкой:

Stack​.​maxSize ​=​ ​100;
Stack​.​head ​=​ NULL;


Добавление элемента. Push

Проверяем, что мы можем добавлять элемент в стек. В противном случае выводим сообщение об
ошибке и завершаем выполнение функции.

if​ ​(​Stack​.​size ​>=​ ​Stack​.​maxSize​)​ {
	printf​(​"Error stack size"​);
	​return;
}

Создаём указатель на узел:

Node​ ​*​tmp;

Выделяем для него место в памяти и сохраняем ссылку:

Tmp​ ​=​ ​(​Node​*)​ malloc​(​sizeof​(​Node​));

Записываем данные в новый узел:

tmp​->​value ​=​ value​;​ ​// записываем данные
tmp​->​next​ ​=​ ​Stack​.​head​;​ ​// записываем предыдущее значение главы

head теперь указывает на вновь созданный элемент:

Stack​.​head ​=​ tmp​;​ ​// голова теперь указывает на вновь созданный элемент
Stack​.​size​++;​ ​// увеличиваем количество элементов в стеке


Извлечение элемента. Pop

Проверяем размер стека. Если он пуст, то выводим соответствующее сообщение и ничего не
делаем.

if​ ​(​Stack​.​size ​==​ ​0​)
{
	printf​(​"Stack is empty"​);
	​return;
}

Создаём временный указатель:

Node​*​ ​next​ ​=​ NULL;

Так как мы должны удалить вершину списка, требуется предварительно сохранить данные из
вершины:

T value;
Value​ ​=​ ​Stack​.​head​->​value;

Запоминаем значение головы во временной переменной:

Next​ ​=​ ​Stack​.​head;

Записываем в голову предыдущий элемент:

Stack​.​head ​=​ ​Stack​.​head​->​next;

А запись, на которую указывала голова, удаляем, освобождая память:

free​(​next​);

Возвращаем значение, которое было в голове, и уменьшаем количество элементов:

Stack​.​size​--;
return​ value;


Распечатка односвязного списка

Для распечатки стека нам нужно пробежаться по всем элементам списка, начиная с головы, до
тех пор, пока мы не найдём элемента, значение поля next у которого будет равно NULL.

void​ ​PrintStack​(​struct​ ​Stack​ ​Stack)
{
	​Node​ ​*​current ​=​ ​Stack​.​head;
	​while​(​current ​!=​ NULL)
	{
		printf​(​"%c "​,​ current​->​value​);
		current ​=​ current​->​next;
	}
}

Полный текст программы:

#include <stdio.h>
#include <malloc.h>

#define T char

// Опишем структуру узла списка
struct TNode
{
	T value;
	struct TNode *next;
};
typedef struct TNode Node;

struct Stack
{
	Node *head;
	int size;
	int maxSize;
};
struct Stack Stack;

void push(T value)
{
	if (Stack.size >= Stack.maxSize)
	{
		printf("Error stack size");
		return;
	}
	Node *tmp = (Node*) malloc(sizeof(Node));
	tmp->value = value;
	tmp->next = Stack.head;
	Stack.head = tmp;
	Stack.size++;

}

T pop()
{
	if (Stack.size == 0)
	{
		printf("Stack is empty");
		return;
	}
	// Временный указатель
	Node* next = NULL;
	// Значение "наверху" списка
	T value;
	value = Stack.head->value;
	Next = Stack.head;
	Stack.head = Stack.head->next;
	// Запись, на которую указывала голова удаляем, освобождая память
	free(next);
	// Возвращаем значение, которое было в голове
	Stack.size--;
	return value;
}

void PtintStack()
{
	Node *current = Stack.head;
	while(current != NULL)
	{
		printf("%c", current->value);
		current = current->next;
	}
}

int main(int argc, char *argv[])
{
	Stack.maxSize = 100;
	Stack.head = NULL;

	push('a');
	push('b');
	push('c');
	push('d');
	push('e');
	push('f');

	PrintStack();

	return 0;
}


###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 235)

Использование односвязных списков сопряжено с рядом проблем, большая часть которых
вызвана тем, что невозможно возвращаться к началу списка. Все эти трудности можно решить
путем добавления указателей возпрата. При добавлении этих связей в односвязный список он
становится двусвязным.

Двусвязный список отличается от односвязного тем, что элемент
этого списка содержит не только указатель на следующий элемент, но и указатель на
предыдущий элемент. Это увеличивает накладные расходы, связанные со структурой списка,
но они почти вceгдa окупаются, так как повышают мощь, уровень гибкости и нaдежность
приложения.

Листинги в папке Listings.
dllist.c
dllist.h
dllistmn.c

7.3.3. Циклические списки
###########################(Из методички 5.)
Если замкнуть связный список в кольцо так, чтобы последний элемент содержал ссылку на
первый, то получается циклический список.

(Картинка примера в методичке)

###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 242)

Циклические списки - это OДHO- или двусвязные списки, которые, если можно так выразиться,
гоняются за своим собственным хвостом: А указывает на В, В указывает на С, С указывает на
D, D указывает на Е и Е указывает на А. Они лучше вceгo подходят для циклических данных.

В циклическом списке отсутствуют первый и последний элементы. Поэтому полезно ввести
понятие текушей позиции, через которую выполняются все операции. Если нужный элемент
находится не на текушей позиции, то мы можем как бы поворачивать список до тех пор, пока
не получим элемент, который требуется. Обычно за один раз приложение поворачивает список
на один элемент, но при необходимости может поворачивать и на большее число элементов.
Эти вращения осуществляются очень быстро, так как в действительности данные в памяти не
пересылаются требуется только присвоить новое значение указателю.

Листинги в папке Listings.
clist.c
clist.h
clistmn.c

