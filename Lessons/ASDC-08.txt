8. Деревья
	8.1. Виды деревьев
		8.1.1. Двоичное дерево поиска
			8.1.1.1. Хранение двоичного дерева в массиве
		8.1.2. Красно-чёрные деревья
			8.1.2.1. Свойства красно-чёрных деревьев
				8.1.2.1.1. Лемма
			8.1.2.2. Повороты
			8.1.2.3. Вставка
			8.1.2.4. Удаление
		8.1.3. Деревья 2-3-4
		8.1.4. Деревья поиска
	8.2. Использование динамических структур данных
	8.3. Скобочная запись дерева
	8.4. Рекурсивный обход двоичного дерева
	8.5. Построение сбалансированного дерева
	8.6. Бинарный поиск в дереве
	8.7. Пирамидальная сортировка (Heap sort)

8. Деревья
###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 331)

Для иллюстрации описываемого подхода к организации данных рассмотрим простую задачу:
требуется очень быстро найти слово в компьютеризированном словаре. Для начального поиска
выбирается первая буква слова, скажем "S", и рассматриваются только те слова, которые
начинаются с буквы "S". Если в словаре оказывается более одного слова, начинающегося с
этой буквы, выделяем следуюшую букву в слове, скажем "t", и pacсматриваем только те слова
в словаре, которые начинаются с букв "St". Этот метод просмотра букв искомого слова
продолжается до тех пор, пока не наберется количество букв, достаточное для его
однозначной идентификации с зaданным словом.

Поиск данных в дереве выполняется точно так же. Ключ, по которому осуществляется поиск,
разбивается на части (в предыдущем примере это были различные буквы, составляющие
заданное слово), затем последовательно используется каждая такая часть для определения
ветви дерева, по которой следует двигаться дальше.

Формально структура типа дерево может состоять из нуля или более узлов. Узел дерева
может не иметь ответвлений, и в этом случае он называется листом. Узел может иметь
несколько других дочерних узлов, и тогда будем называть eгo поддеревом. Каждый
добавленный к узлу дерева лист имеет соответствующий ключ. Необходимо, чтобы ключ в каждом
листе указывал путь к этому листу. Требуется также, чтобы у поддерева было как минимум
два листа.

Листинги в папке Listings.
test_trie.c
trie.c
trie.h
trie_extra.c
trie_internal.h

###########################(Методичка урока 6)
Дерево — это структура, отражающая иерархию (отношения подчиненности, многоуровневые
связи).

Дерево состоит из узлов и связей между ними (они называются дугами). Самый первый
узел, расположенный на верхнем уровне — это корень дерева. Конечные узлы, из которых не
выходит ни одна дуга, называются листьями. Все остальные узлы, кроме корня и листьев, —
промежуточные. Из двух связанных узлов тот, который находится на более высоком уровне,
называется родителем, а другой — сыном. Корень — это единственный узел, у которого
нет родителя; у листьев нет сыновей.

Используются также понятия «предок» и «потомок». Потомок некоторого узла — узел, в
который можно перейти по стрелкам от узла-предка. Соответственно, предок какого-то узла —
это узел, из которого можно перейти по стрелкам в данный узел.

В рисунке родитель узла F — это узел B, а предки узла F — это B и A, для которых узел F —
потомок. Потомками узла A (корня дерева) являются все остальные узлы.

(Картинка дерева в методичке.)

Высота дерева   — это наибольшее расстояние (количество дуг) от корня до листа. Высота
дерева на рисунке равна 3.

Формально дерево можно определить следующим образом:
1. Пустая структура — это дерево.
2. Дерево — это корень и несколько связанных с ним отдельных (не связанных между собой)
деревьев.

Здесь множество объектов (дерево) определяется через само это множество на основе простого
базового случая — пустого дерева. Такой прием называется рекурсией. Согласно этому
определению, дерево — это рекурсивная структура данных. Поэтому можно ожидать, что при
работе с деревьями будут полезны рекурсивные алгоритмы.

Деревья широко применяются в следующих задачах:
1. Поиск в большом массиве неменяющихся данных.
2. Сортировка данных.
3. Вычисление арифметических выражений.
4. Оптимальное кодирование данных (метод сжатия Хаффмана).

В виде дерева удобно хранить структуру организации компании или каталог частей, из которых
состоит, скажем, автомобиль.

Можно особо отметить DOM (Document Object Model) в HTML. При считывании HTML-страницы
браузер, анализируя HTML, выстраивает иерархию объектов в виде дерева.

(Картинка в методичке.)

Чаще всего в информатике используются двоичные (или бинарные) деревья, т.е. такие, в
которых каждый узел имеет не более двух сыновей. Их также можно определить рекурсивно.

Двоичное дерево:
1. Пустая структура — это двоичное дерево.
2. Двоичное дерево — это корень и два связанных с ним отдельных двоичных дерева (левое и
правое поддеревья).

8.1. Виды деревьев
8.1.1. Двоичное дерево поиска
###########################(Методичка урока 6)
Дан файл с числами произвольной длины. Считать файл с диска и построить по данным файла
двоичное дерево поиска. Реализовать функции считывания данных из файла в двоичное дерево и
поиска заданного числа в двоичном дереве.

Создание двоичного дерева поиска:
(Вероятное содержимое файла data.txt
4
0 4 0 0
0 0 3 6
0 0 2 0
5 6 0 0
)
#include  <stdio.h>
#include  <malloc.h>
#include  <stdlib.h>
typedef  int T;
typedef  struct  Node {
	T data;
	struct  Node  * left;
	struct  Node  * right;
	struct  Node  * parent;
}  Node;
// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );
			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );
			printf ( "," );
			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );
			printf ( ")" );
		}
	}
}
// Создание нового узла
Node * getFreeNode ( T value ,  Node  * parent ) {
	Node * tmp  =  ( Node *) malloc ( sizeof ( Node ));
	tmp -> left  = tmp -> right  = NULL;
	tmp -> data  = value;
	tmp -> parent  = parent;
	return tmp;
}
// Вставка узла
void insert ( Node  ** head ,  int value ) {
	Node  * tmp  = NULL;
	if  (* head  == NULL )
	{
		* head  = getFreeNode ( value , NULL );
		return;
	}
	tmp  =  * head;
	while  ( tmp )
	{
		if  ( value > tmp -> data )
		{
			if  ( tmp -> right )
			{
				tmp  = tmp -> right;
				continue;
			}
			else
			{
				tmp -> right  = getFreeNode ( value , tmp );
				return;
			}
		}
		else  if  ( value < tmp -> data )
		{
			if  ( tmp -> left )
			{
				tmp  = tmp -> left;
				continue;
			}
			else
			{
				tmp -> left  = getFreeNode ( value , tmp );
				return;
			}
		}
		else
		{
			exit ( 2 );  // дерево построено неправильно
		}
	}
}
void preOrderTravers ( Node * root ) {
	if  ( root ) {
		printf ( "%d " , root -> data );
		preOrderTravers ( root -> left );
		preOrderTravers ( root -> right );
	}
}
int main ()
{
	Node  * Tree  = NULL;
	FILE * file  = fopen ( "D:\\temp\\data.txt" ,  "r" );
	if  ( file  == NULL)
	{
		puts ( "Can't open file!" );
		exit ( 1 );
	}
	int count;
	fscanf ( file ,  "%d" ,  & count );  // Считываем количество записей
	int i;
	for ( i  =  0 ; i  < count ; i ++)
	{
		int value;
		fscanf ( file ,  "%d" ,  & value );
		insert (& Tree , value );
	}
	fclose ( file );
	printTree ( Tree );
	printf ( "\nPreOrderTravers:" );
	preOrderTravers ( Tree );
	return  0;
}


8.1.1.1. Хранение двоичного дерева в массиве
###########################(Методичка урока 6)
Двоичные деревья можно хранить в массиве почти так же, как и списки. Вопрос в том, как
сохранить структуру (взаимосвязь узлов). Если нумерация элементов начинается с 1, то
сыновья элемента a[i] — это a[2*i] и a[2*i+1]. Каждому числу 1, 2, 3, 4 будет
соответствовать пара 1 — (2,3), 2 — (4,5), 3 — (6,7) и т.д. На рисунке ниже показано, как
можно сохранить часть двоичного дерева в массиве. Обратите внимание, что некоторые
элементы остались пустыми, это значит, что их родитель — лист дерева.

(Картинка в методичке.)

8.1.2. Красно-чёрные деревья
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 341)

Во пункте 2.2.2. второго урока было показано, что бинарные деревья поиска высоты h
реализуют все базовые операции над динамическими множествами, такие как Search,
Predecessor, Successor, Minimum, Maximum, Insert и Delete, со временем работы O(h). Таким
образом, операции выполняются тем быстрее, чем меньше высота дерева. Однако в наихудшем
случае производительность бинарного дерева поиска оказывается ничуть не лучшей, чем
производительность связанного списка. Красно-чёрные деревья представляют собой одну из
множества "сбалансированных" схем деревьев поиска, которые гарантируют время выполнения
операций над динамическим множеством O(lg n) даже в наихудшем случае.

8.1.2.1. Свойства красно-чёрных деревьев
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 341)

"Красно-чёрное дерево" представляет собой бинарное дерево поиска с одним дополнительным
битом "цвета" в каждом узле. Цвет узла может быть либо красным(RED), либо чёрным(BLACK). В
соответствии с накладываемыми на узлы дерева ограничениями ни один простой путь от корня
в красно-чёрном дереве не отличается от другого по длине более чем в два раза, так что
красно-чёрные деревья являются приближённо "сбалансированными".

Каждый узел дерева содержит атрибуты color, key, left, right и p. Если не существует
дочернего или родительского узла по отношению к данному, соответствующий указатель
принимает значение NIL(NULL?). Мы будем рассматривать эти значения NIL(NULL?), как
указатели на внешние узлы(листья) бинарного дерева поиска. При этом все "нормальные"
узлы, содержащие поле ключа, становятся внутренними узлами дерева.

Бинарное дерево поиска является красно-чёрным деревом, если оно удовлетворяет следующим
"красно-чёрным свойством".

1. Каждый узел является либо красным, либо чёрным.
2. Корень дерева является чёрным узлом.
3. Каждый лист дерева(NIL(NULL?)) является чёрным узлом.
4. Если узел красный, то оба его дочерних узла чёрные.
5. Для каждого узла все простые пути от него до листьев, являющихся потомками данного
узла, содержит одно и то же количество чёрных узлов.

На рис. 13.1,(а)(страница в книге 343) приведен пример красного чёрного дерева.

Для удобства работы с граничными условиями в красно-чёрных деревьях мы заменим все
листья одним ограничивающим узлом, представляющим значение NIL(NULL?). В красно-чёрном
дереве T ограничитель T.nil представляет собой объект с теми же атрибутами, что и обычный
узел дерева. Значение color этого узла равно BLACK(чёрный), а все остальные атрибуты - p,
left, right и key - могут иметь произвольные значения. Как показано на рис.
13.1,(б)(страница в книге 343) все указатели на NIL(NULL?) заменяются указателями на
ограничитель T.nil.

Использование ограничителя позволяет нам рассматривать дочерний по отношению к узлу x
NIL(NULL?) как обычный узел, родителем которого является узел x. Хотя можно было бы
использовать различные ограничители для каждого значения NIL(NULL?)(что позволило бы
точно определять их родительские узлы), этот подход привёл бы к неоправданному
перерасходу памяти. Вместо этого мы используем единственный ограничитель T.nil для
представления всех NIL(NULL?) - как листьев, так и родительского узла корня. Значение
атрибутов p, left, right и key ограничителя не играют никакой роли, хотя для удобства мы
можем присвоить им не или иные значения.

В целом мы ограничим наш интерес к красно-чёрным деревьям только их внутренними узлами,
поскольку лишь они хранят значения ключей. В оставшейся части данной главы при
изображении красно-чёрных деревьев все листья опускаются, как это сделано на рис.
13.1,(в)(страница в книге 343).

Количество чёрных узлов на любом простом пути от узла x(не считая сам узел) к листу будем
называть "чёрной высотой"(black-height) узла и обозначать как bh(x). В соответствии со
свойством 5 красно-чёрных деревьев чёрная высота узла - точно определяемое значение,
поскольку все нисходящие простые пути из узла содержат одно и то же количество чёрных
узлов. Чёрной высотой дерева будем считать чёрную высоту его корня.

Следующая лемма показывает, почему красно-чёрные деревья хорошо использовать в качестве
деревьев поиска.

8.1.2.1.1. Лемма
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 342)

Красно-чёрное дерево с n внутренними узлами имеет высоту, не привышающую 2lg(n + 1).

"Доказательство". Начнём с того, что покажем, что поддерево любого узла x содержит как
минимум 2^bh(x) - 1 внутренних узлов. Докажем что это по индукции по высоте x. Если
высота x равна 0, то узел x должен быть листом (T.nil), а поддерево узла x содержит не
менее 2^bh(x) - 1 = 2^ - 1 = 0 внутренних узлов. Теперь для выполнения шага индукции
рассмотрим узел x, который имеет положительную высоту и представляет собой внутренний
узел с двумя потомками. Каждый дочерний узел имеет чёрную высоту либо bh(x), либо bh(x) -
1 в зависимости от того, является ли его цвет соотвественно красным или чёрным. Поскольку
высота потомка x меньше, чем высота самого узла x, мы можем использовать предположение
индукции и сделать вывод о том, что каждый из потомков x имеет как минимум 2^(bh(x)-1) -
1 внутренних узлов. Таким образом, дерево с корнем в вершине x содержит как минимум
(2^(bh(x)-1) - 1) + (2^(bh(x)-1) - 1) + 1 = 2^bh(x) - 1 внутренних узлов, что и
доказывает наше утверждение.

Для того чтобы завершить доказательство леммы, обозначим высоту дерева через h. Согласно
свойству 4 по крайней мере половина узлов на любом простом пути от корня к листу, не
считая сам корень, должны быть чёрными. Следовательно, чёрная высота корня должна
составлять как минимум h/2; значит,

n >= 2^(h/2) - 1 .

Перенося 1 в левую часть и логарифмируя, получим, что lg(n + 1) >= h/2, или
h <= 2lg(n + 1).

Непосредственным следствием леммы является то, что такие операции над динамическими
множествами, как Search, Minimum, Maximum, Predecessor и Successor, при использовании
красно-чёрных деревьев выполняются за время O(lg h), поскольку время работы этих операций
на дереве поиска высотой h составляет O(h), а любое красно-чёрное дерево с n узлами
является деревом поиска высотой O(lg n). (Само собой разумеется, обращение к NIL(NULL?) в
алгоритмах в главе 12 должны быть заменены обращениями к T.nil.) Хотя алгоритмы Tree-
Insert и Tree-Delete из главы 12 и характеризуются временем работы O(lg n), если
использовать их для вставки и удаления из красно-чёрного дерева, непосредственно
использовать их для выполнения операций Insert и Delete нельзя, поскольку они не
гарантируют сохранение красно-чёрных свойств после внесения изменений в дерево. Однако в
разделах 8.1.2.3.(13.3(страница в книге 348)) и 8.1.2.4.(13.4(страница в книге 356)) вы
увидите, что эти операции также могут быть выполнены за время O(lg n).

8.1.2.2. Повороты
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 345)

Операции над деревом поиска Tree-Insert и Tree-Delete, будучи применены к красно-чёрному
дереву с n ключами, выполняются за время O(lg n). Поскольку они изменяют дерево, в
результате их работы могут нарушаться красно-чёрные свойства, перечисленные в разделе
8.1.2.1.(в книге 13.1). Для восстановления этих свойств необходим изменить цвета
некоторых узлов дерева, а также структуру его указателей.

Изменения в структуре указателей будут выполняться с помощью "поворотов"(rotations),
которые представляют собой локальные операции в дереве поиска, сохраняющие свойство
бинарного дерева поиска. На рис 13.2(страница в книге 346) показаны два типа поворотов -
левый и правый. При выполнении левого поворота в узле x предпологается, что его правый
дочерний узел y не является листом T.nil; x может быть любым узлом дерева, правый
дочерний узел которого - не T.nil. Левый поворот выполняется "вокруг" связи между x и y,
делая y новым корнем поддерева, левым дочерним узлом которого становится x, а бывший
левый потомок узла y - правым потомком x.

В псевдокоде процедуры Left-Rotate предпологается, что x.right != T.nil и что родитель
корневого узла - T.nil.

Left-Rotate(T, x)
1	y = x.right			// Установка y
2	x.right = y.left	// Превращение левого поддерева y в правое поддерево x
3	if y.left != T.nil
4		y.left.p = x
5	y.p = x.p			// Передача родителя x узлу y
6	if x.p == T.nil
7		T.root = y
8	elseif x == x.p.left
9		x.p.left = y
10	else x.p.right = y
11	y.left = x			// Размещение x в качестве левого дочернего узла y
12	x.p = y

На рис. 13.3(страница в книге 347) показан конкретный пример изменения бинарного дерева
поиска процедурой Left-Rotate. Код процедуры Right-Rotate симметричен коду Left-Rotate.
Обе эти процедуры выполянются за время O(1). При повороте изменяются только указатели;
все прочие атрибуты сохраняют своё значение.

8.1.2.3. Вставка
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 348)

Вставка узла в красно-чёрное дерево с n узлами может быть выполнена за время O(lg n). Для
вставки узла z в дерево T мы используемнемного модифицированную версию процедуры
Tree-Insert(раздел в книге 12.3 страница 327), которая вставляет узел в дерево, как если
бы это было обычное бинарное дерево поиска, а затем окрашивает его в красный цвет. Для
того чтобы вставка сохраняла красно-чёрные свойства дерева, после неё вызывается
вспомогательная процедура RB-Insert-Fixup, которая перекрашиывает узлы и выполняет
повороты. Вызов RB-Insert(T, z) вставляет в красно-чёрное дерево T узел z с уже
заполненным атрибутом key.

RB-Insert(T, z)
1	y = T.nil
2	x = T.root
3	while x != T.nil
4		y = x
5		if z.key < x.key
6			x = x.left
7		else x = x.right
8	z.p = y
9	if y == T.nil
10		T.root = z
11	elseif z.key < y.key
12		y.left = z
13	else y.right = z
14	z.left = T.nil
15  z.right = T.nil
16  z.color = RED
17	RB-Insert-Fixup(T, z)

Есть четыре отличия между процедурами Tree-Insert и RB-Insert. Во-первых, все NIL(NULL?)
в Tree-Insert заменены на T.nil. Во-вторых, для поддержки корректности структуры дерева в
строках 14 и 15 процедуры RB-Insert выполняется присвоение T.nil атрибутам z.left и
z.right. В третьих, в строке 16 мы назначаем узла z красный цвет. И наконец, в-четвёртых,
поскольку красный цвет z может вызвать нарушение одного из красно-чёрных свойств, в
строке 17 вызывается вспомогательная процедура RB-Insert-Fixup(T, z), назначение которой -
восстановить красно-чёрные свойства дерева.

RB-Insert-Fixup(T, z)
1	while z.p.color == RED
2		if z.p == z.p.p.left
3			y = z.p.p.right
4			if y.color == RED
5				z.p.color = BLACK		// Случай 1
6				y.color = BLACK			// Случай 1
7				z.p.p.color = RED		// Случай 1
8				z = z.p.p				// Случай 1
9			else if z = z.p.right
10					z = z.p				// Случай 2
11					Left-Rotate(T, z)	// Случай 2
12				 z.p.color = BLACK		// Случай 3
13				 z.p.p.color = RED		// Случай 3
14				 Right-Rotate(T, z.p.p)	// Случай 3
15		else(то же, что и в части then, но с заменой "правого"(right) "левым" и наоборот)
16	T.root.color = BLACK

Для того чтобы понять, как работает процедура RB-Insert-Fixup, разобьём изучение кода на
три части. Сначала определим, какие из красно-чёрных свойств нарушаются при вставке узла
z и его окраске в красный цвет. Затем рассмотрим назначение цикла while в строках 1-15.
После этого изучим каждый из трёх случаев(случаи 2 и 3 не являются взаимоисключающими),
которые встречаются в этом цикле, и посмотрим, каким образом достигается цель в каждом из
них. На рис. 13.4(страница в книге 350) показан пример работы процедуры RB-Insert-Fixup.

Какие из красно-чёрных свойств могут быть нарушены перед вызовом RB-Insert-Fixup?
Свойство 1, определённо, выполняется(как и свойство 3), так как оба дочерних узла
вставляемого узла являются ограничителями T.nil. Свойство 5, согласно которому для
каждого узла все пути от него до листьев, являющихся потомками данного узла, содержат
одно и то же количество чёрных узлов, также остаётся в силе, поскольку узел z замещает
(чёрный) ограничитель, будучи при этом красным и имея чёрные дочерние узлы. Таким
образом, может нарушаться только свойство 2, которое требует, чтобы корень красно-чёрного
дерева был чёрным, и свойство 4, согласно которому красный узел не может иметь красного
потомка. Оба нарушения возможны в силу того, что узел z после вставки окрашивается в
красный цвет. Свойство 2 оказывается нарушенным, если узел z становится корнем, а
свойство 4 - если родительский по отношению к z узел является красным. На рис.
13.4,(а)(страница в книге 350) показано нарушение свойства 4 после вставки узла z.

Цикл while в строках 1-15 сохраняет в начале каждой итерации цикла следующий инвариант,
состоящий из трёх частей:

а. Узел z красный.
б. Если z.p является корнем, то z.p чёрный.
в. Если имеется нарушение красно-чёрных свойств, то это нарушение только одно - нарушение
либо свойства 2, либо свойства 4. Если нарушено свойство 2, то это вызвано тем, что
корнем дерева является красный узел z; если нарушено свойство 4, то в этом случае
красными являются узлы z и z.p.

Часть (в), в которой говорится о возможных нарушениях красно-чёрных свойств, наиболее
важна для того, чтобы показать, что процедура RB-Insert-Fixup восстанавливает
красно-чёрные свойства. Части (а) и (б) просто поясняют ситуацию. Поскольку мы
сосредотачиваем своё рассмотрение только на узле z и узлах, находящихся в дереве вблизи
него, полезно знать, что узел z - красный(часть(а)). Часть (б) используется для того,
чтобы показать, что узел z.p.p, к которому мы обращаемся в строках 2,3,7,8,13 и 14,
существует.

Вспомним, что необходим показать, что инвариант цикла выполняется перед первой итерацией
цикла. что любая итерация цикла сохраняет инвариант и что инвариант цикла обеспечивает
выполнение требуемого свойства по окончании работы цикла.

Начнём с рассмотрения инициализации и завершения работы цикла, а затем, подбронее
рассмотрев работу цикла, докажем, что он сохраняет инвариант цикла. Попутно покажем, что
есть только два возможных варианта действий в каждой итерации цикла - указатель z
перемещается вверх по дереву или выполняются некоторые повороты и цикл завершается.

"Инициализация". Перед выполнением первой итерации цикла имеется красно-чёрное дерево без
каких-либо нарушений красно-чёрных свойств, к которому мы добавляем красный узел z.
Покажем, что все части инварианта цикла выполняются к моменту вызова процедуры
RB-Insert-Fixup.

а. В момент вызова процедуры RB-Insert-Fixup узел z - вставленный в дерево красный узел.
б. Если узел z.p является корнем, то он чёрный и не изменяется до вызова процедуры
RB-Insert-Fixup.
в. Мы уже убедились в том, что красно-чёрные свойства 1, 3 и 5 сохраняются к моменту
вызова процедуры RB-Insert-Fixup.
Если нарушается свойство 2, то красный корень должен быть добавленным в дерево узлом z,
который при этом является единственным внутренним узлом дерева. Поскольку и родитель, и
оба потомка z являются ограничителями, свойство 4 не нарушается. Таким образом, нарушение
свойства 2 - единственное нарушение красно-чёрных свойств во всём дереве.
Если же нарушено свойство 4, то, поскольку дочерние по отношению к z узлы являются
чёрными ограничителями, а до вставки z никаких нарушений красно-чёрных свойств в дереве
не было, нарушение заключается в том, что и z, и z.p - красные. Кроме этого, других
нарушений красно-чёрных свойств не имеется.

"Завершение". Цикл завершает свою работу, когда z.p становится чёрным (если z - корневой
узел, то z.p представляет собой чёрный ограничитель T.nil). Таким образом, свойство 4 при
завершении цикла не нарушается. В соответствии с инвариантом цикла единственным
нарушением красно-чёрных свойств может быть нарушение свойства 2. В строке 16 это
свойство восстанавливается, так что по завершении работы процедуры RB-Insert-Fixup все
красно-чёрные свойства дерева выполняются.

"Сохранение". В действительности во время работы цикла while следует рассмотреть шесть
разных случаев, однаки три из них симметричны трём другим; разница лишь в том, является
ли родитель z.p левым или правым дочерним узлом по отношению к своему родителю z.p.p, что
и выясняется в строке 2(мы привели код только для ситуации, когда z.p является левым
потомком). Узел z.p.p существует, поскольку, в соответствии с частью (б) инварианта
цикла, если z.p - корень дерева, то он чёрный. Поскольку цикл начинает работу, только
если z.p - красный, то z.p не может быть корнем. Следовательно, z.p.p существует.

Случай 1 отличается от случаев 2 и 3 цветом "брата" родительского по отношению к z узла,
т.е. "дяди" узла z. После выполнения строки 3 указатель y указывает на дядю узла z - узел
z.p.p.right, а в строке 4 проверяется его цвет. Если y - красный, выполняется код для
случай 1; в противном случае выполняется код для случаев 2 и 3.В любом случае узел z.p.p
- чёрный, поскольку узел z.p - красный, а свойство 4 нарушается только между z и z.p.

Случай 1. "Дядя" у узла z - красный

На рис. 13.5(страница в книге 353) показана ситуация, возникающая в случае 1(строки 5-8),
когда и z.p, и y - красные узлы. Поскольку узел z.p.p - чёрный, мы можем исправить
ситуацию, когда и z, и z.p оба красные, покрасив и z.p, и y в чёрный цвет. Мы можем также
окрасить z.p.p в красный цвет, тем самым поддержав свойство 5. После этого мы повторяем
цикл while с узлом z.p.p в качестве нового узла z. Указатель z, таким образом,
перемещается на два уровня вверх по дереву.

Теперь покажем, что в случае 1 инвариант цикла сохраняется. Обозначим через узел z узел z
в текущей итерации, а через z' = z.p.p - узел, который будет называться z в проверке в
строке 1 в следующей итерации.

а. Поскольку в данной итерации цвет узла z.p.p становится красным, в начале следующей
итерации узел z' - красный.
б. Узел z'.p в текущей итерации - z.p.p.p, и цвет данного узла в пределах данной итерации
не изменяется. Если это корневой узел, то его цвет до начала данной итерации был чёрным и
остаётся таковым в начале следующей итерации.
в. Мы уже доказали, что в случае 1 свойство 5 сохраняется; кроме того, понятно, что при
выполнении итерации не возникает нарушения свойства 1 или 3.

Если узел z' в начале очередной итерации является корнем, то код, соответствующий случаю
1, корректирует единственное нарушение свойства 4. Поскольку узел z' - красный и
корневой, единственным нарушением становится свойство 2, причём это нарушение связано с
узлом z'.
Если узел z' в начале следующей итерации является корнем, то код, соответствующий случаю
1, корректирует единственное нарушение свойства 4, имеющееся перед выполнением итерации.
Поскольку z' - узел красный и корневой, свойство 2 становится единственным нарушенным, и
это нарушение вызвано узлом z'.
Если узел z' в начале следующей итерации корнем не является, то код, соответствующий
случаю 1, не вызывает нарушения свойства 2. Этот код корректирует единственное нарушение
свойства 4, имеющееся перед выполнением итерации. Коррекция выражается в том, что узел z'
становится красным и оставляет узел z'.p нетронутым. Если узел z'.p был чёрным, то
свойство 4 не нарушается; если же этот узел был красным, то окрашивание узла z' в красный
цвет приводит к нарушению свойства 4 между узлами z' и z'.p.

Случай 2. "Дядя" у узла z чёрный, и z - правый потомок
Случай 3. "Дядя" у узла z чёрный, и z - левый потомок

В случаях 2 и 3 цвет узла y, являющегося "дядей" узла z, чёрный. Эти два случая
отличаются один от другого тем, что z является левым или правым дочерним узлом по
отношению к родительскому узлу z.p. Строки 10 и 11 псевдокода соответствуют случаю 2,
который показан на рис.13.6(страница в книге 354) вместе со случаем 3. В случае 2 узел z
является правым потомком своего родительского узла. Мы используем левый поворот для
преобразования сложившейся ситуации в случай 3(строки 12-14), когда z является левым
потомком. Поскольку и z, и z.p - красные узлы, поворот не влияет ни на чёрную высоту
узлов, ни на выполнение свойства 5. Когда мы приходим к случаю 3(либо непосредственно,
либо поворотом из случая 2), узел y, дядя узла z, имеет чёрный цвет (поскольку иначе мы
бы получили случай 1). Кроме того, обязательно существует узел z.p.p, так как мы
доказали, что этот узел существовал при выполнении строк 2 и 3, а также что после
перемещения узал z на один узел вверх в стрке 10 с последующим опусканием на один уровень
в строке 11 узел z.p.p остаётся неизменным. В случае 3 мы выполняем ряд изменений цвета и
правый поворот, которые сохраняют свойство 5. После этого, так как у нас нет двух идущих
подряд красных узлов, работа процедуры завершается. Больше тело цикла while не
выполняется, так как узел z.p теперь чёрный.

Покажем, что случаи 2 и 3 сохраняют инвариант цикла. (Как мы только что доказали, перед
следующей проверкой в тсроке 1 узел z.p будет чёрным и тело цикла больше выполняться не
будет.)

а. В случае 2 выполняется присвоение, после которого z указывает на красный узел z.p.
Никаких других изменений z или его цвета в случаях 2 и 3 не выполняется.

б. В случае 3 узел z.p делается чёрным, так что если z.p в начале следующей итерации
является корнем, то этот корень - чёрный.

в. Как и в случае 1, в случаях 2 и 3 свойства 1, 3 и 5 сохраняются.
Поскольку узел z в случаях 2 и 3 не является корнем, нарушение свойства 2 невозможно.
Случаи 2 и 3 не могут приводить к нарушению свойства 2, поскольку при повороте в случае 3
сделанный красным узел становится дочерним по отношению к чёрному.
Таким образом, случаи 2 и 3 приводят к коррекции нарушения свойства 4, при этом не внося
никаких новых нарушений красно-чёрных свойств.

Показав, что при любой итерации инвариант цикла сохраняется, мы тем самым показали, что
процедура RB-Insert-Fixup корректно восстанавливает красно-чёрные свойства дерева.

Анализ.

Чему равно время работы процедуры RB-Insert? Поскольку высота красно-чёрного дерева с n
узлами равно O(lg n), выполнение строк 1-16 процедуры RB-Insert требует времени O(lg n).
В процедуре RB-Insert-Fixup цикл while повторно выполняется только в случае 1, и
указатель z при этом перемещается вверх по дереву на два уровня. Таким образом, общее
количество возможных выполнений тела цикла while равно O(lg n). Следовательно, общее
время работы процедуры RB-Insert равно O(lg n). Интересно, что в ней никогда не
выполняется больше двух поворотов, поскольку цикл while в случаях 2 и 3 завершает работу.

8.1.2.4. Удаление
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 356)

Как и остальные базовые операции над красно-чёрными деревьями с n узлами, удаление узла
выполняется за время O(lg n). Удаление оказывается несколько более сложной задачей, чем
вставка.

Процедура для удаления узла из красно-чёрного дерева основана на процедуре Tree-Delete
(раздел 12.3 страница 327 в книге). Сначала нужно внести изменения в подпрограмму
Transplant, которую процедура Tree-Delete вызывает п процессе работы с красно-чёрным
деревом.

RB-Transplant(T, u, v)
1	if u.p == T.nil
2		T.root = v
3	elseif u == u.p.left
4		u.p.left = v
5	else u.p.right = v
6	v.p = u.p

Процедура RB-Transplant имеет два отличия от процедуры Transplant. Во-первых, строка 1
обращается к ограничителю T.nil, а не к NIL(NULL?). Во-вторых, присваивание атрибуту v.p
в строке 6 выполняется безусловно; возможно выполнение присваивания, даже если v
указывает на ограничитель. В действительности мы будем использовать возможность
присваивания атрибуту v.p при v = T.nil.

Процедура RB-Delete подобна процедуре Tree-Delete, но имеет дополнительные строки
псевдокода. Некоторые из них отслеживают узел y, который может вызвать нарушение
красно-чёрных свойств. Если нужно удалить узел z и z имеет меньше двух дочерних узлов, то
z удаляется из дерева, и мы делаем y совпадающим с z. Если у z два дочерних узла, то узел
y должен быть преемником z в дереве, и y перемещается в дереве в позицию узла z. Мы также
запоминаем цвет y перед его удалением или перемещением и отслеживаем узел x, который
перемещается в исходную позицию узла y в дереве, поскольку узел x также может привести к
нарушению красно-чёрных свойств. После удаления узла z процедура RB-Delete вызывает
вспомогательную процедуру RB-Delete-Fixup, которая изменяет цвета и выполняет повороты
для восстановления свойств красно-чёрного дерева.

RB-Delete(T, z)
1	y = z
2	y-original-color = y.color
3	if z.left = T.nil
4		x = z.right
5		RB-Transplant(T, z, z.right)
6	elseif z.right = T.nil
7		x = z.left
8		RB-Transplant(T, z, z.left)
9	else y = Tree-Minimum(z.right)
10		y-original-color = y.color
11		x = y.right
12		if y.p == z
13			x.p = y
14		else RB-Transplant(T, y, y.right)
15			y.right = z.right
16			y.right.p = y
17		RB-Transplant(T, z, y)
18		y.left = z.left
19		y.left.p = y
20		y.color = z.color
21	if y-original-color = BLACK
22		RB-Delete-Fixup(T, x)

Хотя процедура RB-Delete содержит почти в два раза больше строк, чем псевдокод
Tree-Delete, обе эти части процедуры имеют одинаковую базовую структуру. Каждую строку
Tree-Delete можно найти в RB-Delete (с тем отличием, что NIL(NULL?) T.nil, а вызов
Transplant - вызовом RB-Transplant), и выполняются эти строки при одних и тех же условиях.

А вот отличия между этими двумя процедурами.

 - Мы поддерживаем узел y в качестве узла, либо удалённого из дерева, либо перемещённого
в пределах последнего. В строке 1 y становится указывающим на узел z, если z имеет меньше
двух дочерних узлов и, таким образом, оказывается удалённым. Когда z имеет два дочерних
узла, в строке 9 становится указывающим на узел, следующий в дереве за z , так же, как в
процедуре Tree-Delete, и y перемещается в дереве в позицию узла z.

 - Поскольку цвет узла y может измениться, переменная y-original-color хранит цвет узла y
до любых изменений цвета. В строках 2 и 10 выполняется установка этой переменной
немедленно после присваивания значения переменной y. Когда z имеет два дочерних узла, то
y != z и узел y перемещается в исходную позицию узла z в красно-чёрном дереве; строка 20
назначает y тот же цвет, что и цвет узла z. Необходимо хранить исходный цвет y для его
проверки в конце процедуры RB-Delete; если он был чёрным, то удаление или перемещение y
может привести к нарушениям свойств красно-чёрного дерева.

 - Как уже говорилось, мы отслжеиваем узел x, который перемещается в исходную позицию
узла y. Присваивания в строках 4, 7 и 11 делают x указывающим либо на единственный
дочерний узел узла y, либо, если y не имеет дочерних узлов, на ограничитель T.nil.

 - Поскольку узел x перемещается в исходную позицию узла y, атрибут x.p всегда
устаналивается указывающим на исходную позицию родительского по отношению к y узла в
дереве, даже если x в действительности является ограничителем T.nil. Присваивание
атрибуту x.p в строке 6 процедуры RB-Transplant имеет место во всех случаях, кроме
ситуации, когда z исходно является родителем y (что осуществляется, только когда z имеет
два дочерних узла и следующий за z элемент y представляет собой правый дочерний узел z).
(Заметим, что когда RB-Transplant вызывается в строке 5, 8 или 14, третий передаваемый
параметр совпадает с x.)
Однако если исходным родительским узлоа узла y является узел z, нам не нужно, чтобы
атрибут x.p указывал на исходный родитель y, поскольку мы удаляем этот узел из дерева.
Поскольку узел y передвинется вверх и займёт в дереве позицию узла z, установка x.p
равным y в строке 13 приведёт к тому, что x.p будет указывать на исходную позицию
родителя y, даже если x - T.nil.

 - Наконец, если узел y был чёрным, в свойства красно-чёрного дерева может быть внесено
одно или несколько нарушений, так что восстановления свойств красно-чёрного дерева в
строке 22 выполняется вызов RB-Delete-Fixup. Если узел y был красным, при переименовании
или удалении узла y красно-чёрные свойства сохраняются по следующим причинам.

1. Ни одна чёрная высота в дереве не меняется.
2. Никакие красные узлы не делаются сложными. Поскольку y занимает в дереве место z
вместе с цветом узла z, мы не можем получить два смежных красных узла в новой позиции
узла y в дереве. Кроме того, если y не был правым дочерним узлом z, исходный правый
дочерний узел x узла y заменяет последний в дереве. Если y красный, то x должен быть
чёрным, так что замена y на x не может привести к тому, что два красных узла станут
смежными.
3. Поскольку узел y не может быть корнем, если он был красным, корень остаётся чёрным.

Если узел y был чёрным, то могут возникнуть три проблемы, которые исправит вызов
RB-Delete-Fixup. Во-первых, если y был корнем, а теперь новым корнем стал красный потомок
y, нарушается свойство 2. Во-вторых, если и x и x.p красные, то нарушается свойство 4. И
в-третьих, перемещение y в дереве приводит к тому, что любой простой путь, ранее
сводержавший y, теперь имеет на один чёрный узел меньше. Таким образом, для всех предков
y оказывается нарушенным свойство 5. Мы можем исправить ситуацию, утверждая, что узел x,
ныне занимающий исходную позицию y, - "сверхчёрный", т.е. при рассмотрении любого
простого пути, проходящего через x, следует добавлять дополнительную единицу к количеству
чёрных узлов. При такой интерпретации свойство 5 остаётся выполняющимся. При удалении или
перемещении чёрного узла y мы передаём его "черноту" узлу x. Проблема заключается в том,
что теперь узел x не является ни чёрным, ни красным, что нарушает свойство 1. Вмето этого
узел x окрашен либо "дважды чёрным", либо "красно-чёрным" цветом, что даёт при подсчёте
чёрных узлов на простых путях, содержащих x, вклад, равный соответственно 2 или 1.
Атрибут color узла x при этом остаётся равным либо RED (если узел красно-чёрный), либо
BLACK(если узел дважды чёрный). Другими словами, цвет узла x не соотвествует его атрибуту
color.

Теперь рассмотрим процедуру RB-Delete-Fixup и то, как она восстанавливает красно-чёрные
свойства дерева поиска.

RB-Delete-Fixup(T, x)
1	while x != T.root и x.color == BLACK
2		if x == x.p.left
3			w = x.p.right
4			if w.color = RED
5			w.color = BLACK									// Случай 1
6			x.p.color = RED									// Случай 1
7			Left-Rotate(T, x.p)								// Случай 1
8			w = x.p.right									// Случай 1
9		if w.left.color == BLACK и w.right.color == BLACK
10			w.color = RED									// Случай 2
11			x = x.p											// Случай 2
12		else if w.right.color == BLACK
13				w.left.color = BLACK n						// Случай 3
14				nw.color = RED								// Случай 3
15				Right-Rotate(T, w)							// Случай 3
16				w = x.p.right								// Случай 3
17  		 w.color = x.p.color							// Случай 4
18			 x.p.color = BLACK								// Случай 4
19			 w.right.color = BLACK							// Случай 4
20			 Left-Rotate(T, x.p)							// Случай 4
21			 x = T.root										// Случай 4
22		else(то же, что и в части then, но с заменой "правого"(right) "левым"(left) и
				наоборот)
23	x.color = BLACK

Процедура RB-Delete-Fixup восстанавливает свойства 1, 2 и 4. В упр. 13.4.1(страница в
книге 363) и 13.4.2(страница в книге 363) требуется показать, что эта процедура
восстанавливает свойства 2 и 4, так что в оставшейся части раздела мы обратим своё
внимание на свойство 1. Цель цикла while в строках 1-22 заключается в перенесении
дополнительной "черноты" вверх по дереву до тех пор, пока не выполнится одно из следующих
условий.

1. x указывает на красно-чёрный узел - в этом случае мы просто делаем узел x "единожды
чёрным" в строке 23.
2. x указывает на корень - в этом случае мы просто убираем излишнюю черноту.
3. Выполнив некоторые повороты и перекраску, мы выходим из цикла.

Внутри цикла while x всегда указывает на дважды чёрный узел, не являющийся корнем. В
строке 2 мы определяем, является ли x левым или правым дочерним узлом своего родителя
x.p. (Приведен подробный код для ситуации, когда x - левый потомок. Для правого потомка
код аналогичен, симметричен и скрыт за описанием в строке 22.) Поддерживается указатель
w, который указывает на второй потомок родителя x. Поскольку узел x дважды чёрный, узел w
не может быть T.nil; в противном случае количество чёрных узлов на простом пути от x.p к
(единожды чёрному) листу w было бы меньше, чем количество чёрных узлов на простом пути от
x.p к x.

Четыре разных возможных случая(как и в процедуре RB-Insert-Fixup, случаи в процедуре
RB-Delete-Fixup не являются взаимоисключающими) показаны на рис. 13.7(страница в книге
361). Перед тем как приступить к детальному рассмотрению каждого случая, убедимся, что в
каждом из случаев преобразования сохраняется свойство 5. Ключевая идея заключается в
необходимости убедиться, что применяемые преобразования в каждом случае сохраняют
количество чёрных узлов(включая дополнительную черноту в x) на пути от корня включительно
до каждого из поддеревьев α, β, ..., ζ(в книге греческие буквы, альфа, бета и т.д.).
Таким образом, если свойство 5 выполнилось до преобразования, оно выполняется и после
него. Например, на рис.13.7,(а)(страница в книге 361), который иллюстрирует случай 1,
количество чёрных узлов по пути от корня до поддеревьев α(альфа) и β(бета) равно 3 как
до, так и после преобразования(не забудьте о том, что узел x - дважды чёрный). Аналогично
количество чёрных узлов на пути от корня до любого из поддеревьев γ(гамма), δ(дельта),
ε(епсилон) и ζ(дзета) равно 2 как до, так и после преобразования. На рис.13.7,(б)(страница
в книге 361) подсчёт должен включать значение c, равное значению атрибута color корня
показанного поддерева, которое может быть либо RED, либо BLACK. Если определить
count(RED) = 0 и count(BLACK) = 1, то на пути от корня до поддерева α(альфа) количество
чёрных узлов равно 2+count(c); эта величина одинакова до и после выполнения
преобразований. В такой ситуации после преобразования новый узел x имеет атрибут color,
равный c, но реально это либо красно-чёрный узел(если c = RED), либо дважды чёрный
(если с = BLACK). Прочие случаи могут быть проверены аналогично(см. упр. 13.4.5(страница
363)).

Случай 1. Брат w узла x - красный

Случай 1(строки 5-8 процедуры RB-Delete-Fixup и рис.13.7,(а)(страница в книге 361))
возникает, когда узел w("брат" узла x) - красный. Поскольку w должен иметь чёрные
потомки, можно обменять цвета w и x.p, а затем выполнить левый поворот вокруг x.p без
нарушения каких-либо красно-чёрных свойств. Новый "брат" x, до поворота бывший одним из
дочерних узлов w, теперь чёрный. Таким путём случай 1 приводится к случаю 2, 3 или 4.

Случаи 2, 3 и 4 возникают при чёрном узле w и отличаются один от другого цветами дочерних
по отношению к w узлов.

Случай 2. Узел w - чёрный, оба его дочерних узла - чёрные

В этом случае(строки 10 и 11 процедуры RB-Delete-Fixup и рис.13.7,(б)) оба дочерних узла
w - чёрные. Поскольку узел w также , мы можем забрать чёрную окраску у x и w, сделав x
единожды чёрным, а w - красным. Для того чтобы компенсировать удаление чёрной окрасик x и
w, мы можем добавить дополнительный чёрный узлу x.p, который до этого мог быть как
красным, так и чёрным. После этого будет выполнена следующая итерация цикла, в которой
роль x будет играть текущий узел x.p. Заметим, что если мы переходим к случаю 2 от случая
1, новый узел x - красно-чёрный, поскольку исходный узел x.p был красным. Следовательно,
значение c атрибута color нового узла x равно RED и цикл завершается при проверке условия
цикла. После этого новый узел x окрашивается в обычный чёрный цвет в строке 23.

Случай 3. Брат w узла x - чёрный, левый дочерний узел узла w - красный, а правый чёрный

В этом случае(строки 13-16 процедуры RB-Delete-Fixup и рис.13.7,(в)(страница в книге
361)) узел w - чёрный, его левый дочерний узел - красный, а правый - чёрный. Мы можем
обменять цвета w и его дочернего узла w.left, а затем выполнить правый поворот вокруг w
без нарушения каких-либо красно-чёрных свойств. Новым "братом" узла x после этого будет
чёрный узел с красным правым дочерним узлом, и, таким образом, случай 3 приводится к
случаю 4.

Случай 4. Брат w узла x чёрный, а правый дочерний узел узла w красный

В этом случае(строки 17-21 процедуры RB-Delete-Fixup и рис.13.7,(г)(страница в книге
361)) узел w - чёрный, а его правый дочерний узел - красный. Выполняя обмен цветом и
левый поворот вокруг x.p, мы можем устранить излишнюю черноту в x, делая его простым
чёрным, без нарушения каких-либо красно-чёрных свойств. Присвоение x указателя на корень
дерева приводит к завершению работы цикла при проверке условия при следующей итерации.

Анализ

Чему равно время работы процедуры RB-Delete? Поскольку высота дерева с n узлами равна
O(lg n), общая стоимость процедуры без вызова вспомогательной процедуры RB-Delete-Fixup
равна O(lg n). В процедуре RB-Delete-Fixup в случаях 1, 3 и 4 завершение работы
происходит после выполнения фиксированного числа изменений цвета и не более трёх
поворотов. Случай 2 - единственный, после которого возможно выполнение очередной итерации
цикла while, причём указатель x перемещается вверх по дереву не более чем O(lg n) раз и
никакие повороты при этом не выполняются. Таким образом, время работы процедуры
RB-Delete-Fixup составляет O(lg n), причём она выполняет не более трёх поворотов. Общее
время работы процедуры RB-Delete, само собой разумеется равно O(lg n).

8.1.3. Деревья 2-3-4
8.1.4. Деревья поиска
###########################(Методичка урока 6)
Чтобы найти заданный элемент в неупорядоченном массиве из N элементов, может понадобиться
N сравнений. Теперь предположим, что элементы массива организованы в виде специальным
образом построенного дерева, например, как показано на рисунке:

(Картинка в методичке.)

Значения, связанные с узлами дерева, по которым выполняется поиск, называются ключами этих
узлов (кроме ключа узел может содержать множество других данных). Перечислим важные
свойства дерева, показанного на рисунке:

1. Слева от каждого узла находятся узлы, ключи которых меньше или равны ключу данного
узла.
2. Справа от каждого узла находятся узлы, ключи которых больше данного узла.

Дерево, обладающее такими свойствами, называется  двоичным деревом поиска.

Например, пусть нужно найти узел, ключ которого равен 6. Начинаем поиск по дереву с корня.
Ключ корня — 8 (больше заданного), поэтому дальше нужно искать только в левом поддереве и
т.д. Если при линейном поиске в массиве за одно сравнение отсекается 1 элемент, здесь —
сразу примерно половина оставшихся. Количество операций сравнения в этом случае
пропорционально log 2 N, т.е. алгоритм имеет асимптотическую сложность O(log2 N).
Конечно, нужно учитывать, что предварительно дерево должно быть построено. Поэтому такой
алгоритм выгодно применять в тех случаях, когда данные меняются редко, а поиск
выполняется часто (например, в базах данных).

Индексация базы данных как раз и есть упорядочивание элементов с использования структур
типа двоичного дерева. В дальнейшем это позволяет сократить время поиска в базе данных.

8.2. Использование динамических структур данных
###########################(Методичка урока 6)
Поскольку двоичное дерево — это нелинейная структура данных, мы будем использовать
связанные узлы. Каждый такой узел — структура, содержащая три области: область данных,
ссылка на левое поддерево (указатель) и ссылка на правое поддерево (второй указатель).
Также иногда добавляют указатель на предыдущий узел (Parent). У листьев нет сыновей, в
этом случае в указатели будем записывать значение NULL (нулевой указатель).

Пример дерева, состоящего из пяти таких узлов:

(Картинка в методичке.)

Структура, описывающая узел дерева:

typedef  struct  Node {
T data;
 struct  Node  * left;
 struct  Node  * right;
 struct  Node  * parent;
}  Node;

8.3. Скобочная запись дерева
###########################(Методичка урока 6)
Так как изобразить дерево графически — довольно сложная задача, мы будем использовать
скобочную запись. Например, дерево, представленное на рисунке ниже, в скобочной записи
будет выглядеть следующим образом:

8(9(12(16,NULL),6),15(6(5,NULL),12))

NULL означает отсутствие узла.

(Картинка в методичке.)

// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );

			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );

			printf ( "," );

			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );

			printf ( ")" );
		}
	}
}

8.4. Рекурсивный обход двоичного дерева
###########################(Методичка урока 6)
Существует несколько способов обхода дерева:

1. КЛП — «корень–левый–правый»  (обход в прямом порядке, pre-order):
	a. Посетить корень.
	b. Обойти левое поддерево.
	c. Обойти правое поддерево.

(Картинка в методичке.)

Рекурсивное решение полностью соответствует описанию алгоритма:

void preOrderTravers ( Node * root ) {
	if  ( root ) {
		printf ( "%d " , root -> data );
		preOrderTravers ( root -> left );
		preOrderTravers ( root -> right );
	}
}

2. ЛКП — «левый–корень–правый»  (симметричный обход, in-order):
	a. Обойти левое поддерево.
	b. Посетить корень.
	c. Обойти правое поддерево.

(Картинка в методичке.)

СимметричныйОбход(Узел*)
{
	если  узел  не  пуст,  то
	{
		СимметричныйОбход(Узел->Левый)
		вывести  Узел-> data
		СимметричныйОбход(Узел->Правый)
	}
}

3. ЛПК — «левый–правый–корень»  (обход в обратном порядке, post-order):
	a. Обойти левое поддерево.
	b. Обойти правое поддерево.
	c. Посетить корень.

(Картинка в методичке.)

ОбратныйОбход(Узел*)
{
	если  узел  не  пуст,  то
	{
		ОбратныйОбход(Узел->Левый)
		ОбратныйОбход(Узел->Правый)
		вывести  Узел-> data
	}
}

Как видим, это рекурсивные алгоритмы. Они должны заканчиваться без повторного вызова,
когда текущий корень — пустое дерево.

8.5. Построение сбалансированного дерева
###########################(Методичка урока 6)
Предположим, что нужно построить дерево, значениями в узлах которого являются n чисел,
считываемых из входного файла. Чтобы сделать задачу интересней, будем строить дерево с n
узлами, имеющее минимальную высоту. Чтобы получить минимальную высоту при заданном числе
узлов, нужно размещать максимально возможное число узлов на всех уровнях, кроме самого
нижнего. Очевидно, этого можно достичь, распределяя новые узлы поровну слева и справа от
каждого узла.

Пример сбалансированного дерева на рисунке ниже:

(Картинка в методичке.)

Правило равномерного распределения при известном числе узлов n лучше всего сформулировать
рекурсивно:

1. Использовать один узел в качестве корня.
2. Построить таким образом левое поддерево с числом узлов nl=n div 2.
3. Построить таким образом правое поддерево с числом узлов nr=n-nl-1.

Это правило реализуется рекурсивной процедурой, которая читает входной файл и строит
идеально сбалансированное дерево. Дерево является идеально сбалансированным, если для
каждого узла число узлов в левом и правом поддеревьях отличается не больше, чем на 1.

(Вероятное содержимое файла data.txt
4
0 4 0 0
0 0 3 6
0 0 2 0
5 6 0 0
)

#include  <stdio.h>
#include  <malloc.h>
#include  <stdlib.h>

typedef  int T;
FILE * file;

typedef  struct  Node {
	T data;
	struct  Node  * left;
	struct  Node  * right;
}  Node;
// Построить идеально сбалансированное дерево с n узлами
Node *  Tree ( int n)
{
	Node * newNode;
	int x , nl , nr;
	if  ( n  ==  0 )
		newNode = NULL;
	else
	{
		fscanf (file, "%d", &x);
		nl = n / 2;
		nr = n - nl - 1;
		newNode = (Node*) malloc(sizeof(Node));
		newNode -> data  = x;
		newNode -> left  =  Tree ( nl );
		newNode -> right  =  Tree ( nr );
	}
	return newNode;
}
// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );
			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );
			printf ( "," );
			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );
			printf ( ")" );
		}
	}
}

int main ()
{
	Node * tree  = NULL;
	file  = fopen ( "d:\\temp\\data.txt" , "r" );
	if  ( file  == NULL)
	{
		puts ( "Can't open file!" );
		return  1;
	}
	int count;
	fscanf ( file ,  "%d" ,  & count );  // Считываем количество записей
	tree  =  Tree ( count );
	fclose ( file );
	printTree ( tree );
	return  0;
}


8.6. Бинарный поиск в дереве
8.7. Пирамидальная сортировка (Heap sort)
