8. Деревья
	8.1. Виды деревьев
		8.1.1. Двоичное дерево поиска
			8.1.1.1. Хранение двоичного дерева в массиве
		8.1.2. Красно-чёрные деревья
			8.1.2.1. Свойства красно-чёрных деревьев
				8.1.2.1.1. Лемма
			8.1.2.2. Повороты
			8.1.2.3. Вставка
			8.1.2.4. Удаление
		8.1.3. Деревья 2-3-4
			8.1.3.1. Почему деревья 2-3-4 так называются?
			8.1.3.2. Структура дерева 2-3-4
			8.1.3.3. Поиск в дереве 2-3-4
			8.1.3.4. Вставка
			8.1.3.5. Разбиение узлов
			8.1.3.6. Разбиение корневого узла
			8.1.3.7. Разбиение при перемещении вниз
		8.1.4. Деревья поиска
	8.2. Использование динамических структур данных
	8.3. Скобочная запись дерева
	8.4. Рекурсивный обход двоичного дерева
	8.5. Построение сбалансированного дерева
	8.6. Бинарный поиск в дереве
		8.6.1. Что такое бинарное дерево поиска
		8.6.2. Работа с бинарным деревом поиска
		8.6.3. Вставка и удаление
		8.6.4. Случайное построение бинарных деревьев поиска
	8.7. Пирамидальная сортировка (Heap sort)

8. Деревья
###########################(Хэзфилд Р., Кирби Л. - Искусство программирования на C -
2001.djvu. Страница 331)

Для иллюстрации описываемого подхода к организации данных рассмотрим простую задачу:
требуется очень быстро найти слово в компьютеризированном словаре. Для начального поиска
выбирается первая буква слова, скажем "S", и рассматриваются только те слова, которые
начинаются с буквы "S". Если в словаре оказывается более одного слова, начинающегося с
этой буквы, выделяем следуюшую букву в слове, скажем "t", и pacсматриваем только те слова
в словаре, которые начинаются с букв "St". Этот метод просмотра букв искомого слова
продолжается до тех пор, пока не наберется количество букв, достаточное для его
однозначной идентификации с зaданным словом.

Поиск данных в дереве выполняется точно так же. Ключ, по которому осуществляется поиск,
разбивается на части (в предыдущем примере это были различные буквы, составляющие
заданное слово), затем последовательно используется каждая такая часть для определения
ветви дерева, по которой следует двигаться дальше.

Формально структура типа дерево может состоять из нуля или более узлов. Узел дерева
может не иметь ответвлений, и в этом случае он называется листом. Узел может иметь
несколько других дочерних узлов, и тогда будем называть eгo поддеревом. Каждый
добавленный к узлу дерева лист имеет соответствующий ключ. Необходимо, чтобы ключ в каждом
листе указывал путь к этому листу. Требуется также, чтобы у поддерева было как минимум
два листа.

Листинги в папке Listings.
test_trie.c
trie.c
trie.h
trie_extra.c
trie_internal.h

###########################(Методичка урока 6)
Дерево — это структура, отражающая иерархию (отношения подчиненности, многоуровневые
связи).

Дерево состоит из узлов и связей между ними (они называются дугами). Самый первый
узел, расположенный на верхнем уровне — это корень дерева. Конечные узлы, из которых не
выходит ни одна дуга, называются листьями. Все остальные узлы, кроме корня и листьев, —
промежуточные. Из двух связанных узлов тот, который находится на более высоком уровне,
называется родителем, а другой — сыном. Корень — это единственный узел, у которого
нет родителя; у листьев нет сыновей.

Используются также понятия «предок» и «потомок». Потомок некоторого узла — узел, в
который можно перейти по стрелкам от узла-предка. Соответственно, предок какого-то узла —
это узел, из которого можно перейти по стрелкам в данный узел.

В рисунке родитель узла F — это узел B, а предки узла F — это B и A, для которых узел F —
потомок. Потомками узла A (корня дерева) являются все остальные узлы.

(Картинка дерева в методичке.)

Высота дерева   — это наибольшее расстояние (количество дуг) от корня до листа. Высота
дерева на рисунке равна 3.

Формально дерево можно определить следующим образом:
1. Пустая структура — это дерево.
2. Дерево — это корень и несколько связанных с ним отдельных (не связанных между собой)
деревьев.

Здесь множество объектов (дерево) определяется через само это множество на основе простого
базового случая — пустого дерева. Такой прием называется рекурсией. Согласно этому
определению, дерево — это рекурсивная структура данных. Поэтому можно ожидать, что при
работе с деревьями будут полезны рекурсивные алгоритмы.

Деревья широко применяются в следующих задачах:
1. Поиск в большом массиве неменяющихся данных.
2. Сортировка данных.
3. Вычисление арифметических выражений.
4. Оптимальное кодирование данных (метод сжатия Хаффмана).

В виде дерева удобно хранить структуру организации компании или каталог частей, из которых
состоит, скажем, автомобиль.

Можно особо отметить DOM (Document Object Model) в HTML. При считывании HTML-страницы
браузер, анализируя HTML, выстраивает иерархию объектов в виде дерева.

(Картинка в методичке.)

Чаще всего в информатике используются двоичные (или бинарные) деревья, т.е. такие, в
которых каждый узел имеет не более двух сыновей. Их также можно определить рекурсивно.

Двоичное дерево:
1. Пустая структура — это двоичное дерево.
2. Двоичное дерево — это корень и два связанных с ним отдельных двоичных дерева (левое и
правое поддеревья).

8.1. Виды деревьев
8.1.1. Двоичное дерево поиска
###########################(Методичка урока 6)
Дан файл с числами произвольной длины. Считать файл с диска и построить по данным файла
двоичное дерево поиска. Реализовать функции считывания данных из файла в двоичное дерево и
поиска заданного числа в двоичном дереве.

Создание двоичного дерева поиска:
(Вероятное содержимое файла data.txt
4
0 4 0 0
0 0 3 6
0 0 2 0
5 6 0 0
)
#include  <stdio.h>
#include  <malloc.h>
#include  <stdlib.h>
typedef  int T;
typedef  struct  Node {
	T data;
	struct  Node  * left;
	struct  Node  * right;
	struct  Node  * parent;
}  Node;
// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );
			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );
			printf ( "," );
			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );
			printf ( ")" );
		}
	}
}
// Создание нового узла
Node * getFreeNode ( T value ,  Node  * parent ) {
	Node * tmp  =  ( Node *) malloc ( sizeof ( Node ));
	tmp -> left  = tmp -> right  = NULL;
	tmp -> data  = value;
	tmp -> parent  = parent;
	return tmp;
}
// Вставка узла
void insert ( Node  ** head ,  int value ) {
	Node  * tmp  = NULL;
	if  (* head  == NULL )
	{
		* head  = getFreeNode ( value , NULL );
		return;
	}
	tmp  =  * head;
	while  ( tmp )
	{
		if  ( value > tmp -> data )
		{
			if  ( tmp -> right )
			{
				tmp  = tmp -> right;
				continue;
			}
			else
			{
				tmp -> right  = getFreeNode ( value , tmp );
				return;
			}
		}
		else  if  ( value < tmp -> data )
		{
			if  ( tmp -> left )
			{
				tmp  = tmp -> left;
				continue;
			}
			else
			{
				tmp -> left  = getFreeNode ( value , tmp );
				return;
			}
		}
		else
		{
			exit ( 2 );  // дерево построено неправильно
		}
	}
}
void preOrderTravers ( Node * root ) {
	if  ( root ) {
		printf ( "%d " , root -> data );
		preOrderTravers ( root -> left );
		preOrderTravers ( root -> right );
	}
}
int main ()
{
	Node  * Tree  = NULL;
	FILE * file  = fopen ( "D:\\temp\\data.txt" ,  "r" );
	if  ( file  == NULL)
	{
		puts ( "Can't open file!" );
		exit ( 1 );
	}
	int count;
	fscanf ( file ,  "%d" ,  & count );  // Считываем количество записей
	int i;
	for ( i  =  0 ; i  < count ; i ++)
	{
		int value;
		fscanf ( file ,  "%d" ,  & value );
		insert (& Tree , value );
	}
	fclose ( file );
	printTree ( Tree );
	printf ( "\nPreOrderTravers:" );
	preOrderTravers ( Tree );
	return  0;
}


8.1.1.1. Хранение двоичного дерева в массиве
###########################(Методичка урока 6)
Двоичные деревья можно хранить в массиве почти так же, как и списки. Вопрос в том, как
сохранить структуру (взаимосвязь узлов). Если нумерация элементов начинается с 1, то
сыновья элемента a[i] — это a[2*i] и a[2*i+1]. Каждому числу 1, 2, 3, 4 будет
соответствовать пара 1 — (2,3), 2 — (4,5), 3 — (6,7) и т.д. На рисунке ниже показано, как
можно сохранить часть двоичного дерева в массиве. Обратите внимание, что некоторые
элементы остались пустыми, это значит, что их родитель — лист дерева.

(Картинка в методичке.)

8.1.2. Красно-чёрные деревья
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 341)

Во пункте 2.2.2. второго урока было показано, что бинарные деревья поиска высоты h
реализуют все базовые операции над динамическими множествами, такие как Search,
Predecessor, Successor, Minimum, Maximum, Insert и Delete, со временем работы O(h). Таким
образом, операции выполняются тем быстрее, чем меньше высота дерева. Однако в наихудшем
случае производительность бинарного дерева поиска оказывается ничуть не лучшей, чем
производительность связанного списка. Красно-чёрные деревья представляют собой одну из
множества "сбалансированных" схем деревьев поиска, которые гарантируют время выполнения
операций над динамическим множеством O(lg n) даже в наихудшем случае.

8.1.2.1. Свойства красно-чёрных деревьев
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 341)

"Красно-чёрное дерево" представляет собой бинарное дерево поиска с одним дополнительным
битом "цвета" в каждом узле. Цвет узла может быть либо красным(RED), либо чёрным(BLACK). В
соответствии с накладываемыми на узлы дерева ограничениями ни один простой путь от корня
в красно-чёрном дереве не отличается от другого по длине более чем в два раза, так что
красно-чёрные деревья являются приближённо "сбалансированными".

Каждый узел дерева содержит атрибуты color, key, left, right и p. Если не существует
дочернего или родительского узла по отношению к данному, соответствующий указатель
принимает значение NIL(NULL?). Мы будем рассматривать эти значения NIL(NULL?), как
указатели на внешние узлы(листья) бинарного дерева поиска. При этом все "нормальные"
узлы, содержащие поле ключа, становятся внутренними узлами дерева.

Бинарное дерево поиска является красно-чёрным деревом, если оно удовлетворяет следующим
"красно-чёрным свойством".

1. Каждый узел является либо красным, либо чёрным.
2. Корень дерева является чёрным узлом.
3. Каждый лист дерева(NIL(NULL?)) является чёрным узлом.
4. Если узел красный, то оба его дочерних узла чёрные.
5. Для каждого узла все простые пути от него до листьев, являющихся потомками данного
узла, содержит одно и то же количество чёрных узлов.

На рис. 13.1,(а)(страница в книге 343) приведен пример красного чёрного дерева.

Для удобства работы с граничными условиями в красно-чёрных деревьях мы заменим все
листья одним ограничивающим узлом, представляющим значение NIL(NULL?). В красно-чёрном
дереве T ограничитель T.nil представляет собой объект с теми же атрибутами, что и обычный
узел дерева. Значение color этого узла равно BLACK(чёрный), а все остальные атрибуты - p,
left, right и key - могут иметь произвольные значения. Как показано на рис.
13.1,(б)(страница в книге 343) все указатели на NIL(NULL?) заменяются указателями на
ограничитель T.nil.

Использование ограничителя позволяет нам рассматривать дочерний по отношению к узлу x
NIL(NULL?) как обычный узел, родителем которого является узел x. Хотя можно было бы
использовать различные ограничители для каждого значения NIL(NULL?)(что позволило бы
точно определять их родительские узлы), этот подход привёл бы к неоправданному
перерасходу памяти. Вместо этого мы используем единственный ограничитель T.nil для
представления всех NIL(NULL?) - как листьев, так и родительского узла корня. Значение
атрибутов p, left, right и key ограничителя не играют никакой роли, хотя для удобства мы
можем присвоить им не или иные значения.

В целом мы ограничим наш интерес к красно-чёрным деревьям только их внутренними узлами,
поскольку лишь они хранят значения ключей. В оставшейся части данной главы при
изображении красно-чёрных деревьев все листья опускаются, как это сделано на рис.
13.1,(в)(страница в книге 343).

Количество чёрных узлов на любом простом пути от узла x(не считая сам узел) к листу будем
называть "чёрной высотой"(black-height) узла и обозначать как bh(x). В соответствии со
свойством 5 красно-чёрных деревьев чёрная высота узла - точно определяемое значение,
поскольку все нисходящие простые пути из узла содержат одно и то же количество чёрных
узлов. Чёрной высотой дерева будем считать чёрную высоту его корня.

Следующая лемма показывает, почему красно-чёрные деревья хорошо использовать в качестве
деревьев поиска.

8.1.2.1.1. Лемма
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 342)

Красно-чёрное дерево с n внутренними узлами имеет высоту, не привышающую 2lg(n + 1).

"Доказательство". Начнём с того, что покажем, что поддерево любого узла x содержит как
минимум 2^bh(x) - 1 внутренних узлов. Докажем что это по индукции по высоте x. Если
высота x равна 0, то узел x должен быть листом (T.nil), а поддерево узла x содержит не
менее 2^bh(x) - 1 = 2^ - 1 = 0 внутренних узлов. Теперь для выполнения шага индукции
рассмотрим узел x, который имеет положительную высоту и представляет собой внутренний
узел с двумя потомками. Каждый дочерний узел имеет чёрную высоту либо bh(x), либо bh(x) -
1 в зависимости от того, является ли его цвет соотвественно красным или чёрным. Поскольку
высота потомка x меньше, чем высота самого узла x, мы можем использовать предположение
индукции и сделать вывод о том, что каждый из потомков x имеет как минимум 2^(bh(x)-1) -
1 внутренних узлов. Таким образом, дерево с корнем в вершине x содержит как минимум
(2^(bh(x)-1) - 1) + (2^(bh(x)-1) - 1) + 1 = 2^bh(x) - 1 внутренних узлов, что и
доказывает наше утверждение.

Для того чтобы завершить доказательство леммы, обозначим высоту дерева через h. Согласно
свойству 4 по крайней мере половина узлов на любом простом пути от корня к листу, не
считая сам корень, должны быть чёрными. Следовательно, чёрная высота корня должна
составлять как минимум h/2; значит,

n >= 2^(h/2) - 1 .

Перенося 1 в левую часть и логарифмируя, получим, что lg(n + 1) >= h/2, или
h <= 2lg(n + 1).

Непосредственным следствием леммы является то, что такие операции над динамическими
множествами, как Search, Minimum, Maximum, Predecessor и Successor, при использовании
красно-чёрных деревьев выполняются за время O(lg h), поскольку время работы этих операций
на дереве поиска высотой h составляет O(h), а любое красно-чёрное дерево с n узлами
является деревом поиска высотой O(lg n). (Само собой разумеется, обращение к NIL(NULL?) в
алгоритмах в главе 12 должны быть заменены обращениями к T.nil.) Хотя алгоритмы Tree-
Insert и Tree-Delete из главы 12 и характеризуются временем работы O(lg n), если
использовать их для вставки и удаления из красно-чёрного дерева, непосредственно
использовать их для выполнения операций Insert и Delete нельзя, поскольку они не
гарантируют сохранение красно-чёрных свойств после внесения изменений в дерево. Однако в
разделах 8.1.2.3.(13.3(страница в книге 348)) и 8.1.2.4.(13.4(страница в книге 356)) вы
увидите, что эти операции также могут быть выполнены за время O(lg n).

8.1.2.2. Повороты
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 345)

Операции над деревом поиска Tree-Insert и Tree-Delete, будучи применены к красно-чёрному
дереву с n ключами, выполняются за время O(lg n). Поскольку они изменяют дерево, в
результате их работы могут нарушаться красно-чёрные свойства, перечисленные в разделе
8.1.2.1.(в книге 13.1). Для восстановления этих свойств необходим изменить цвета
некоторых узлов дерева, а также структуру его указателей.

Изменения в структуре указателей будут выполняться с помощью "поворотов"(rotations),
которые представляют собой локальные операции в дереве поиска, сохраняющие свойство
бинарного дерева поиска. На рис 13.2(страница в книге 346) показаны два типа поворотов -
левый и правый. При выполнении левого поворота в узле x предпологается, что его правый
дочерний узел y не является листом T.nil; x может быть любым узлом дерева, правый
дочерний узел которого - не T.nil. Левый поворот выполняется "вокруг" связи между x и y,
делая y новым корнем поддерева, левым дочерним узлом которого становится x, а бывший
левый потомок узла y - правым потомком x.

В псевдокоде процедуры Left-Rotate предпологается, что x.right != T.nil и что родитель
корневого узла - T.nil.

Left-Rotate(T, x)
1	y = x.right			// Установка y
2	x.right = y.left	// Превращение левого поддерева y в правое поддерево x
3	if y.left != T.nil
4		y.left.p = x
5	y.p = x.p			// Передача родителя x узлу y
6	if x.p == T.nil
7		T.root = y
8	elseif x == x.p.left
9		x.p.left = y
10	else x.p.right = y
11	y.left = x			// Размещение x в качестве левого дочернего узла y
12	x.p = y

На рис. 13.3(страница в книге 347) показан конкретный пример изменения бинарного дерева
поиска процедурой Left-Rotate. Код процедуры Right-Rotate симметричен коду Left-Rotate.
Обе эти процедуры выполянются за время O(1). При повороте изменяются только указатели;
все прочие атрибуты сохраняют своё значение.

8.1.2.3. Вставка
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 348)

Вставка узла в красно-чёрное дерево с n узлами может быть выполнена за время O(lg n). Для
вставки узла z в дерево T мы используемнемного модифицированную версию процедуры
Tree-Insert(раздел в книге 12.3 страница 327), которая вставляет узел в дерево, как если
бы это было обычное бинарное дерево поиска, а затем окрашивает его в красный цвет. Для
того чтобы вставка сохраняла красно-чёрные свойства дерева, после неё вызывается
вспомогательная процедура RB-Insert-Fixup, которая перекрашиывает узлы и выполняет
повороты. Вызов RB-Insert(T, z) вставляет в красно-чёрное дерево T узел z с уже
заполненным атрибутом key.

RB-Insert(T, z)
1	y = T.nil
2	x = T.root
3	while x != T.nil
4		y = x
5		if z.key < x.key
6			x = x.left
7		else x = x.right
8	z.p = y
9	if y == T.nil
10		T.root = z
11	elseif z.key < y.key
12		y.left = z
13	else y.right = z
14	z.left = T.nil
15  z.right = T.nil
16  z.color = RED
17	RB-Insert-Fixup(T, z)

Есть четыре отличия между процедурами Tree-Insert и RB-Insert. Во-первых, все NIL(NULL?)
в Tree-Insert заменены на T.nil. Во-вторых, для поддержки корректности структуры дерева в
строках 14 и 15 процедуры RB-Insert выполняется присвоение T.nil атрибутам z.left и
z.right. В третьих, в строке 16 мы назначаем узла z красный цвет. И наконец, в-четвёртых,
поскольку красный цвет z может вызвать нарушение одного из красно-чёрных свойств, в
строке 17 вызывается вспомогательная процедура RB-Insert-Fixup(T, z), назначение которой -
восстановить красно-чёрные свойства дерева.

RB-Insert-Fixup(T, z)
1	while z.p.color == RED
2		if z.p == z.p.p.left
3			y = z.p.p.right
4			if y.color == RED
5				z.p.color = BLACK		// Случай 1
6				y.color = BLACK			// Случай 1
7				z.p.p.color = RED		// Случай 1
8				z = z.p.p				// Случай 1
9			else if z = z.p.right
10					z = z.p				// Случай 2
11					Left-Rotate(T, z)	// Случай 2
12				 z.p.color = BLACK		// Случай 3
13				 z.p.p.color = RED		// Случай 3
14				 Right-Rotate(T, z.p.p)	// Случай 3
15		else(то же, что и в части then, но с заменой "правого"(right) "левым" и наоборот)
16	T.root.color = BLACK

Для того чтобы понять, как работает процедура RB-Insert-Fixup, разобьём изучение кода на
три части. Сначала определим, какие из красно-чёрных свойств нарушаются при вставке узла
z и его окраске в красный цвет. Затем рассмотрим назначение цикла while в строках 1-15.
После этого изучим каждый из трёх случаев(случаи 2 и 3 не являются взаимоисключающими),
которые встречаются в этом цикле, и посмотрим, каким образом достигается цель в каждом из
них. На рис. 13.4(страница в книге 350) показан пример работы процедуры RB-Insert-Fixup.

Какие из красно-чёрных свойств могут быть нарушены перед вызовом RB-Insert-Fixup?
Свойство 1, определённо, выполняется(как и свойство 3), так как оба дочерних узла
вставляемого узла являются ограничителями T.nil. Свойство 5, согласно которому для
каждого узла все пути от него до листьев, являющихся потомками данного узла, содержат
одно и то же количество чёрных узлов, также остаётся в силе, поскольку узел z замещает
(чёрный) ограничитель, будучи при этом красным и имея чёрные дочерние узлы. Таким
образом, может нарушаться только свойство 2, которое требует, чтобы корень красно-чёрного
дерева был чёрным, и свойство 4, согласно которому красный узел не может иметь красного
потомка. Оба нарушения возможны в силу того, что узел z после вставки окрашивается в
красный цвет. Свойство 2 оказывается нарушенным, если узел z становится корнем, а
свойство 4 - если родительский по отношению к z узел является красным. На рис.
13.4,(а)(страница в книге 350) показано нарушение свойства 4 после вставки узла z.

Цикл while в строках 1-15 сохраняет в начале каждой итерации цикла следующий инвариант,
состоящий из трёх частей:

а. Узел z красный.
б. Если z.p является корнем, то z.p чёрный.
в. Если имеется нарушение красно-чёрных свойств, то это нарушение только одно - нарушение
либо свойства 2, либо свойства 4. Если нарушено свойство 2, то это вызвано тем, что
корнем дерева является красный узел z; если нарушено свойство 4, то в этом случае
красными являются узлы z и z.p.

Часть (в), в которой говорится о возможных нарушениях красно-чёрных свойств, наиболее
важна для того, чтобы показать, что процедура RB-Insert-Fixup восстанавливает
красно-чёрные свойства. Части (а) и (б) просто поясняют ситуацию. Поскольку мы
сосредотачиваем своё рассмотрение только на узле z и узлах, находящихся в дереве вблизи
него, полезно знать, что узел z - красный(часть(а)). Часть (б) используется для того,
чтобы показать, что узел z.p.p, к которому мы обращаемся в строках 2,3,7,8,13 и 14,
существует.

Вспомним, что необходим показать, что инвариант цикла выполняется перед первой итерацией
цикла. что любая итерация цикла сохраняет инвариант и что инвариант цикла обеспечивает
выполнение требуемого свойства по окончании работы цикла.

Начнём с рассмотрения инициализации и завершения работы цикла, а затем, подбронее
рассмотрев работу цикла, докажем, что он сохраняет инвариант цикла. Попутно покажем, что
есть только два возможных варианта действий в каждой итерации цикла - указатель z
перемещается вверх по дереву или выполняются некоторые повороты и цикл завершается.

"Инициализация". Перед выполнением первой итерации цикла имеется красно-чёрное дерево без
каких-либо нарушений красно-чёрных свойств, к которому мы добавляем красный узел z.
Покажем, что все части инварианта цикла выполняются к моменту вызова процедуры
RB-Insert-Fixup.

а. В момент вызова процедуры RB-Insert-Fixup узел z - вставленный в дерево красный узел.
б. Если узел z.p является корнем, то он чёрный и не изменяется до вызова процедуры
RB-Insert-Fixup.
в. Мы уже убедились в том, что красно-чёрные свойства 1, 3 и 5 сохраняются к моменту
вызова процедуры RB-Insert-Fixup.
Если нарушается свойство 2, то красный корень должен быть добавленным в дерево узлом z,
который при этом является единственным внутренним узлом дерева. Поскольку и родитель, и
оба потомка z являются ограничителями, свойство 4 не нарушается. Таким образом, нарушение
свойства 2 - единственное нарушение красно-чёрных свойств во всём дереве.
Если же нарушено свойство 4, то, поскольку дочерние по отношению к z узлы являются
чёрными ограничителями, а до вставки z никаких нарушений красно-чёрных свойств в дереве
не было, нарушение заключается в том, что и z, и z.p - красные. Кроме этого, других
нарушений красно-чёрных свойств не имеется.

"Завершение". Цикл завершает свою работу, когда z.p становится чёрным (если z - корневой
узел, то z.p представляет собой чёрный ограничитель T.nil). Таким образом, свойство 4 при
завершении цикла не нарушается. В соответствии с инвариантом цикла единственным
нарушением красно-чёрных свойств может быть нарушение свойства 2. В строке 16 это
свойство восстанавливается, так что по завершении работы процедуры RB-Insert-Fixup все
красно-чёрные свойства дерева выполняются.

"Сохранение". В действительности во время работы цикла while следует рассмотреть шесть
разных случаев, однаки три из них симметричны трём другим; разница лишь в том, является
ли родитель z.p левым или правым дочерним узлом по отношению к своему родителю z.p.p, что
и выясняется в строке 2(мы привели код только для ситуации, когда z.p является левым
потомком). Узел z.p.p существует, поскольку, в соответствии с частью (б) инварианта
цикла, если z.p - корень дерева, то он чёрный. Поскольку цикл начинает работу, только
если z.p - красный, то z.p не может быть корнем. Следовательно, z.p.p существует.

Случай 1 отличается от случаев 2 и 3 цветом "брата" родительского по отношению к z узла,
т.е. "дяди" узла z. После выполнения строки 3 указатель y указывает на дядю узла z - узел
z.p.p.right, а в строке 4 проверяется его цвет. Если y - красный, выполняется код для
случай 1; в противном случае выполняется код для случаев 2 и 3.В любом случае узел z.p.p
- чёрный, поскольку узел z.p - красный, а свойство 4 нарушается только между z и z.p.

Случай 1. "Дядя" у узла z - красный

На рис. 13.5(страница в книге 353) показана ситуация, возникающая в случае 1(строки 5-8),
когда и z.p, и y - красные узлы. Поскольку узел z.p.p - чёрный, мы можем исправить
ситуацию, когда и z, и z.p оба красные, покрасив и z.p, и y в чёрный цвет. Мы можем также
окрасить z.p.p в красный цвет, тем самым поддержав свойство 5. После этого мы повторяем
цикл while с узлом z.p.p в качестве нового узла z. Указатель z, таким образом,
перемещается на два уровня вверх по дереву.

Теперь покажем, что в случае 1 инвариант цикла сохраняется. Обозначим через узел z узел z
в текущей итерации, а через z' = z.p.p - узел, который будет называться z в проверке в
строке 1 в следующей итерации.

а. Поскольку в данной итерации цвет узла z.p.p становится красным, в начале следующей
итерации узел z' - красный.
б. Узел z'.p в текущей итерации - z.p.p.p, и цвет данного узла в пределах данной итерации
не изменяется. Если это корневой узел, то его цвет до начала данной итерации был чёрным и
остаётся таковым в начале следующей итерации.
в. Мы уже доказали, что в случае 1 свойство 5 сохраняется; кроме того, понятно, что при
выполнении итерации не возникает нарушения свойства 1 или 3.

Если узел z' в начале очередной итерации является корнем, то код, соответствующий случаю
1, корректирует единственное нарушение свойства 4. Поскольку узел z' - красный и
корневой, единственным нарушением становится свойство 2, причём это нарушение связано с
узлом z'.
Если узел z' в начале следующей итерации является корнем, то код, соответствующий случаю
1, корректирует единственное нарушение свойства 4, имеющееся перед выполнением итерации.
Поскольку z' - узел красный и корневой, свойство 2 становится единственным нарушенным, и
это нарушение вызвано узлом z'.
Если узел z' в начале следующей итерации корнем не является, то код, соответствующий
случаю 1, не вызывает нарушения свойства 2. Этот код корректирует единственное нарушение
свойства 4, имеющееся перед выполнением итерации. Коррекция выражается в том, что узел z'
становится красным и оставляет узел z'.p нетронутым. Если узел z'.p был чёрным, то
свойство 4 не нарушается; если же этот узел был красным, то окрашивание узла z' в красный
цвет приводит к нарушению свойства 4 между узлами z' и z'.p.

Случай 2. "Дядя" у узла z чёрный, и z - правый потомок
Случай 3. "Дядя" у узла z чёрный, и z - левый потомок

В случаях 2 и 3 цвет узла y, являющегося "дядей" узла z, чёрный. Эти два случая
отличаются один от другого тем, что z является левым или правым дочерним узлом по
отношению к родительскому узлу z.p. Строки 10 и 11 псевдокода соответствуют случаю 2,
который показан на рис.13.6(страница в книге 354) вместе со случаем 3. В случае 2 узел z
является правым потомком своего родительского узла. Мы используем левый поворот для
преобразования сложившейся ситуации в случай 3(строки 12-14), когда z является левым
потомком. Поскольку и z, и z.p - красные узлы, поворот не влияет ни на чёрную высоту
узлов, ни на выполнение свойства 5. Когда мы приходим к случаю 3(либо непосредственно,
либо поворотом из случая 2), узел y, дядя узла z, имеет чёрный цвет (поскольку иначе мы
бы получили случай 1). Кроме того, обязательно существует узел z.p.p, так как мы
доказали, что этот узел существовал при выполнении строк 2 и 3, а также что после
перемещения узал z на один узел вверх в стрке 10 с последующим опусканием на один уровень
в строке 11 узел z.p.p остаётся неизменным. В случае 3 мы выполняем ряд изменений цвета и
правый поворот, которые сохраняют свойство 5. После этого, так как у нас нет двух идущих
подряд красных узлов, работа процедуры завершается. Больше тело цикла while не
выполняется, так как узел z.p теперь чёрный.

Покажем, что случаи 2 и 3 сохраняют инвариант цикла. (Как мы только что доказали, перед
следующей проверкой в тсроке 1 узел z.p будет чёрным и тело цикла больше выполняться не
будет.)

а. В случае 2 выполняется присвоение, после которого z указывает на красный узел z.p.
Никаких других изменений z или его цвета в случаях 2 и 3 не выполняется.

б. В случае 3 узел z.p делается чёрным, так что если z.p в начале следующей итерации
является корнем, то этот корень - чёрный.

в. Как и в случае 1, в случаях 2 и 3 свойства 1, 3 и 5 сохраняются.
Поскольку узел z в случаях 2 и 3 не является корнем, нарушение свойства 2 невозможно.
Случаи 2 и 3 не могут приводить к нарушению свойства 2, поскольку при повороте в случае 3
сделанный красным узел становится дочерним по отношению к чёрному.
Таким образом, случаи 2 и 3 приводят к коррекции нарушения свойства 4, при этом не внося
никаких новых нарушений красно-чёрных свойств.

Показав, что при любой итерации инвариант цикла сохраняется, мы тем самым показали, что
процедура RB-Insert-Fixup корректно восстанавливает красно-чёрные свойства дерева.

Анализ.

Чему равно время работы процедуры RB-Insert? Поскольку высота красно-чёрного дерева с n
узлами равно O(lg n), выполнение строк 1-16 процедуры RB-Insert требует времени O(lg n).
В процедуре RB-Insert-Fixup цикл while повторно выполняется только в случае 1, и
указатель z при этом перемещается вверх по дереву на два уровня. Таким образом, общее
количество возможных выполнений тела цикла while равно O(lg n). Следовательно, общее
время работы процедуры RB-Insert равно O(lg n). Интересно, что в ней никогда не
выполняется больше двух поворотов, поскольку цикл while в случаях 2 и 3 завершает работу.

8.1.2.4. Удаление
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu Страница 356)

Как и остальные базовые операции над красно-чёрными деревьями с n узлами, удаление узла
выполняется за время O(lg n). Удаление оказывается несколько более сложной задачей, чем
вставка.

Процедура для удаления узла из красно-чёрного дерева основана на процедуре Tree-Delete
(раздел 12.3 страница 327 в книге). Сначала нужно внести изменения в подпрограмму
Transplant, которую процедура Tree-Delete вызывает п процессе работы с красно-чёрным
деревом.

RB-Transplant(T, u, v)
1	if u.p == T.nil
2		T.root = v
3	elseif u == u.p.left
4		u.p.left = v
5	else u.p.right = v
6	v.p = u.p

Процедура RB-Transplant имеет два отличия от процедуры Transplant. Во-первых, строка 1
обращается к ограничителю T.nil, а не к NIL(NULL?). Во-вторых, присваивание атрибуту v.p
в строке 6 выполняется безусловно; возможно выполнение присваивания, даже если v
указывает на ограничитель. В действительности мы будем использовать возможность
присваивания атрибуту v.p при v = T.nil.

Процедура RB-Delete подобна процедуре Tree-Delete, но имеет дополнительные строки
псевдокода. Некоторые из них отслеживают узел y, который может вызвать нарушение
красно-чёрных свойств. Если нужно удалить узел z и z имеет меньше двух дочерних узлов, то
z удаляется из дерева, и мы делаем y совпадающим с z. Если у z два дочерних узла, то узел
y должен быть преемником z в дереве, и y перемещается в дереве в позицию узла z. Мы также
запоминаем цвет y перед его удалением или перемещением и отслеживаем узел x, который
перемещается в исходную позицию узла y в дереве, поскольку узел x также может привести к
нарушению красно-чёрных свойств. После удаления узла z процедура RB-Delete вызывает
вспомогательную процедуру RB-Delete-Fixup, которая изменяет цвета и выполняет повороты
для восстановления свойств красно-чёрного дерева.

RB-Delete(T, z)
1	y = z
2	y-original-color = y.color
3	if z.left = T.nil
4		x = z.right
5		RB-Transplant(T, z, z.right)
6	elseif z.right = T.nil
7		x = z.left
8		RB-Transplant(T, z, z.left)
9	else y = Tree-Minimum(z.right)
10		y-original-color = y.color
11		x = y.right
12		if y.p == z
13			x.p = y
14		else RB-Transplant(T, y, y.right)
15			y.right = z.right
16			y.right.p = y
17		RB-Transplant(T, z, y)
18		y.left = z.left
19		y.left.p = y
20		y.color = z.color
21	if y-original-color = BLACK
22		RB-Delete-Fixup(T, x)

Хотя процедура RB-Delete содержит почти в два раза больше строк, чем псевдокод
Tree-Delete, обе эти части процедуры имеют одинаковую базовую структуру. Каждую строку
Tree-Delete можно найти в RB-Delete (с тем отличием, что NIL(NULL?) T.nil, а вызов
Transplant - вызовом RB-Transplant), и выполняются эти строки при одних и тех же условиях.

А вот отличия между этими двумя процедурами.

 - Мы поддерживаем узел y в качестве узла, либо удалённого из дерева, либо перемещённого
в пределах последнего. В строке 1 y становится указывающим на узел z, если z имеет меньше
двух дочерних узлов и, таким образом, оказывается удалённым. Когда z имеет два дочерних
узла, в строке 9 становится указывающим на узел, следующий в дереве за z , так же, как в
процедуре Tree-Delete, и y перемещается в дереве в позицию узла z.

 - Поскольку цвет узла y может измениться, переменная y-original-color хранит цвет узла y
до любых изменений цвета. В строках 2 и 10 выполняется установка этой переменной
немедленно после присваивания значения переменной y. Когда z имеет два дочерних узла, то
y != z и узел y перемещается в исходную позицию узла z в красно-чёрном дереве; строка 20
назначает y тот же цвет, что и цвет узла z. Необходимо хранить исходный цвет y для его
проверки в конце процедуры RB-Delete; если он был чёрным, то удаление или перемещение y
может привести к нарушениям свойств красно-чёрного дерева.

 - Как уже говорилось, мы отслжеиваем узел x, который перемещается в исходную позицию
узла y. Присваивания в строках 4, 7 и 11 делают x указывающим либо на единственный
дочерний узел узла y, либо, если y не имеет дочерних узлов, на ограничитель T.nil.

 - Поскольку узел x перемещается в исходную позицию узла y, атрибут x.p всегда
устаналивается указывающим на исходную позицию родительского по отношению к y узла в
дереве, даже если x в действительности является ограничителем T.nil. Присваивание
атрибуту x.p в строке 6 процедуры RB-Transplant имеет место во всех случаях, кроме
ситуации, когда z исходно является родителем y (что осуществляется, только когда z имеет
два дочерних узла и следующий за z элемент y представляет собой правый дочерний узел z).
(Заметим, что когда RB-Transplant вызывается в строке 5, 8 или 14, третий передаваемый
параметр совпадает с x.)
Однако если исходным родительским узлоа узла y является узел z, нам не нужно, чтобы
атрибут x.p указывал на исходный родитель y, поскольку мы удаляем этот узел из дерева.
Поскольку узел y передвинется вверх и займёт в дереве позицию узла z, установка x.p
равным y в строке 13 приведёт к тому, что x.p будет указывать на исходную позицию
родителя y, даже если x - T.nil.

 - Наконец, если узел y был чёрным, в свойства красно-чёрного дерева может быть внесено
одно или несколько нарушений, так что восстановления свойств красно-чёрного дерева в
строке 22 выполняется вызов RB-Delete-Fixup. Если узел y был красным, при переименовании
или удалении узла y красно-чёрные свойства сохраняются по следующим причинам.

1. Ни одна чёрная высота в дереве не меняется.
2. Никакие красные узлы не делаются сложными. Поскольку y занимает в дереве место z
вместе с цветом узла z, мы не можем получить два смежных красных узла в новой позиции
узла y в дереве. Кроме того, если y не был правым дочерним узлом z, исходный правый
дочерний узел x узла y заменяет последний в дереве. Если y красный, то x должен быть
чёрным, так что замена y на x не может привести к тому, что два красных узла станут
смежными.
3. Поскольку узел y не может быть корнем, если он был красным, корень остаётся чёрным.

Если узел y был чёрным, то могут возникнуть три проблемы, которые исправит вызов
RB-Delete-Fixup. Во-первых, если y был корнем, а теперь новым корнем стал красный потомок
y, нарушается свойство 2. Во-вторых, если и x и x.p красные, то нарушается свойство 4. И
в-третьих, перемещение y в дереве приводит к тому, что любой простой путь, ранее
сводержавший y, теперь имеет на один чёрный узел меньше. Таким образом, для всех предков
y оказывается нарушенным свойство 5. Мы можем исправить ситуацию, утверждая, что узел x,
ныне занимающий исходную позицию y, - "сверхчёрный", т.е. при рассмотрении любого
простого пути, проходящего через x, следует добавлять дополнительную единицу к количеству
чёрных узлов. При такой интерпретации свойство 5 остаётся выполняющимся. При удалении или
перемещении чёрного узла y мы передаём его "черноту" узлу x. Проблема заключается в том,
что теперь узел x не является ни чёрным, ни красным, что нарушает свойство 1. Вмето этого
узел x окрашен либо "дважды чёрным", либо "красно-чёрным" цветом, что даёт при подсчёте
чёрных узлов на простых путях, содержащих x, вклад, равный соответственно 2 или 1.
Атрибут color узла x при этом остаётся равным либо RED (если узел красно-чёрный), либо
BLACK(если узел дважды чёрный). Другими словами, цвет узла x не соотвествует его атрибуту
color.

Теперь рассмотрим процедуру RB-Delete-Fixup и то, как она восстанавливает красно-чёрные
свойства дерева поиска.

RB-Delete-Fixup(T, x)
1	while x != T.root и x.color == BLACK
2		if x == x.p.left
3			w = x.p.right
4			if w.color = RED
5			w.color = BLACK									// Случай 1
6			x.p.color = RED									// Случай 1
7			Left-Rotate(T, x.p)								// Случай 1
8			w = x.p.right									// Случай 1
9		if w.left.color == BLACK и w.right.color == BLACK
10			w.color = RED									// Случай 2
11			x = x.p											// Случай 2
12		else if w.right.color == BLACK
13				w.left.color = BLACK n						// Случай 3
14				nw.color = RED								// Случай 3
15				Right-Rotate(T, w)							// Случай 3
16				w = x.p.right								// Случай 3
17  		 w.color = x.p.color							// Случай 4
18			 x.p.color = BLACK								// Случай 4
19			 w.right.color = BLACK							// Случай 4
20			 Left-Rotate(T, x.p)							// Случай 4
21			 x = T.root										// Случай 4
22		else(то же, что и в части then, но с заменой "правого"(right) "левым"(left) и
				наоборот)
23	x.color = BLACK

Процедура RB-Delete-Fixup восстанавливает свойства 1, 2 и 4. В упр. 13.4.1(страница в
книге 363) и 13.4.2(страница в книге 363) требуется показать, что эта процедура
восстанавливает свойства 2 и 4, так что в оставшейся части раздела мы обратим своё
внимание на свойство 1. Цель цикла while в строках 1-22 заключается в перенесении
дополнительной "черноты" вверх по дереву до тех пор, пока не выполнится одно из следующих
условий.

1. x указывает на красно-чёрный узел - в этом случае мы просто делаем узел x "единожды
чёрным" в строке 23.
2. x указывает на корень - в этом случае мы просто убираем излишнюю черноту.
3. Выполнив некоторые повороты и перекраску, мы выходим из цикла.

Внутри цикла while x всегда указывает на дважды чёрный узел, не являющийся корнем. В
строке 2 мы определяем, является ли x левым или правым дочерним узлом своего родителя
x.p. (Приведен подробный код для ситуации, когда x - левый потомок. Для правого потомка
код аналогичен, симметричен и скрыт за описанием в строке 22.) Поддерживается указатель
w, который указывает на второй потомок родителя x. Поскольку узел x дважды чёрный, узел w
не может быть T.nil; в противном случае количество чёрных узлов на простом пути от x.p к
(единожды чёрному) листу w было бы меньше, чем количество чёрных узлов на простом пути от
x.p к x.

Четыре разных возможных случая(как и в процедуре RB-Insert-Fixup, случаи в процедуре
RB-Delete-Fixup не являются взаимоисключающими) показаны на рис. 13.7(страница в книге
361). Перед тем как приступить к детальному рассмотрению каждого случая, убедимся, что в
каждом из случаев преобразования сохраняется свойство 5. Ключевая идея заключается в
необходимости убедиться, что применяемые преобразования в каждом случае сохраняют
количество чёрных узлов(включая дополнительную черноту в x) на пути от корня включительно
до каждого из поддеревьев α, β, ..., ζ(в книге греческие буквы, альфа, бета и т.д.).
Таким образом, если свойство 5 выполнилось до преобразования, оно выполняется и после
него. Например, на рис.13.7,(а)(страница в книге 361), который иллюстрирует случай 1,
количество чёрных узлов по пути от корня до поддеревьев α(альфа) и β(бета) равно 3 как
до, так и после преобразования(не забудьте о том, что узел x - дважды чёрный). Аналогично
количество чёрных узлов на пути от корня до любого из поддеревьев γ(гамма), δ(дельта),
ε(епсилон) и ζ(дзета) равно 2 как до, так и после преобразования. На рис.13.7,(б)(страница
в книге 361) подсчёт должен включать значение c, равное значению атрибута color корня
показанного поддерева, которое может быть либо RED, либо BLACK. Если определить
count(RED) = 0 и count(BLACK) = 1, то на пути от корня до поддерева α(альфа) количество
чёрных узлов равно 2+count(c); эта величина одинакова до и после выполнения
преобразований. В такой ситуации после преобразования новый узел x имеет атрибут color,
равный c, но реально это либо красно-чёрный узел(если c = RED), либо дважды чёрный
(если с = BLACK). Прочие случаи могут быть проверены аналогично(см. упр. 13.4.5(страница
363)).

Случай 1. Брат w узла x - красный

Случай 1(строки 5-8 процедуры RB-Delete-Fixup и рис.13.7,(а)(страница в книге 361))
возникает, когда узел w("брат" узла x) - красный. Поскольку w должен иметь чёрные
потомки, можно обменять цвета w и x.p, а затем выполнить левый поворот вокруг x.p без
нарушения каких-либо красно-чёрных свойств. Новый "брат" x, до поворота бывший одним из
дочерних узлов w, теперь чёрный. Таким путём случай 1 приводится к случаю 2, 3 или 4.

Случаи 2, 3 и 4 возникают при чёрном узле w и отличаются один от другого цветами дочерних
по отношению к w узлов.

Случай 2. Узел w - чёрный, оба его дочерних узла - чёрные

В этом случае(строки 10 и 11 процедуры RB-Delete-Fixup и рис.13.7,(б)) оба дочерних узла
w - чёрные. Поскольку узел w также , мы можем забрать чёрную окраску у x и w, сделав x
единожды чёрным, а w - красным. Для того чтобы компенсировать удаление чёрной окрасик x и
w, мы можем добавить дополнительный чёрный узлу x.p, который до этого мог быть как
красным, так и чёрным. После этого будет выполнена следующая итерация цикла, в которой
роль x будет играть текущий узел x.p. Заметим, что если мы переходим к случаю 2 от случая
1, новый узел x - красно-чёрный, поскольку исходный узел x.p был красным. Следовательно,
значение c атрибута color нового узла x равно RED и цикл завершается при проверке условия
цикла. После этого новый узел x окрашивается в обычный чёрный цвет в строке 23.

Случай 3. Брат w узла x - чёрный, левый дочерний узел узла w - красный, а правый чёрный

В этом случае(строки 13-16 процедуры RB-Delete-Fixup и рис.13.7,(в)(страница в книге
361)) узел w - чёрный, его левый дочерний узел - красный, а правый - чёрный. Мы можем
обменять цвета w и его дочернего узла w.left, а затем выполнить правый поворот вокруг w
без нарушения каких-либо красно-чёрных свойств. Новым "братом" узла x после этого будет
чёрный узел с красным правым дочерним узлом, и, таким образом, случай 3 приводится к
случаю 4.

Случай 4. Брат w узла x чёрный, а правый дочерний узел узла w красный

В этом случае(строки 17-21 процедуры RB-Delete-Fixup и рис.13.7,(г)(страница в книге
361)) узел w - чёрный, а его правый дочерний узел - красный. Выполняя обмен цветом и
левый поворот вокруг x.p, мы можем устранить излишнюю черноту в x, делая его простым
чёрным, без нарушения каких-либо красно-чёрных свойств. Присвоение x указателя на корень
дерева приводит к завершению работы цикла при проверке условия при следующей итерации.

Анализ

Чему равно время работы процедуры RB-Delete? Поскольку высота дерева с n узлами равна
O(lg n), общая стоимость процедуры без вызова вспомогательной процедуры RB-Delete-Fixup
равна O(lg n). В процедуре RB-Delete-Fixup в случаях 1, 3 и 4 завершение работы
происходит после выполнения фиксированного числа изменений цвета и не более трёх
поворотов. Случай 2 - единственный, после которого возможно выполнение очередной итерации
цикла while, причём указатель x перемещается вверх по дереву не более чем O(lg n) раз и
никакие повороты при этом не выполняются. Таким образом, время работы процедуры
RB-Delete-Fixup составляет O(lg n), причём она выполняет не более трёх поворотов. Общее
время работы процедуры RB-Delete, само собой разумеется равно O(lg n).

8.1.3. Деревья 2-3-4
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 436)

В двоичном дереве каждый узел содержит один элемент данных и может иметь до двух
потомков. Дерево с большим количеством элементов данных и потомков называется
многопутевым деревом. Деревья 2­3­4 представляют собой многопутевые деревья, у которых
каждый узел может иметь до четырех потомков и трех элементов данных.

Деревья 2-3-4 представляют интерес по нескольким причинам. Во-первых, это
сбалансированные деревья, которые ведут себя как красно-черные деревья. Они обладают чуть
меньшей эффективностью, чем красно-черные деревья, но проще программируются. Во-вторых
(что самое важное), они упрощают изучение B-деревьев.

B-дерево представляет собой другую разновидность многопутевых деревьев, особенно удобную
для организации данных во внешней памяти (то есть за пределами оперативной памяти; обычно
под внешней памятью понимается дисковое устройство). Узел B-дерева может иметь десятки и
даже сотни потомков.

(пример дерева 2-3-4, страница 436)

8.1.3.1. Почему деревья 2-3-4 так называются?
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 437)

Цифры 2, 3 и 4 в названии дерева обозначают количество связей с потомками, которые могут
содержаться в заданном узле. Для не-листовых узлов возможны три конфигурации:

 - Узел с одним элементом данных всегда имеет двух потомков.
 - Узел с двумя элементами данных всегда имеет трех потомков.
 - Узел с тремя элементами данных всегда имеет четырех потомков.

Короче говоря, количество потомков у не-листового узла всегда на единицу больше
количества элементов данных. Или если выразить это соотношение в виде формулы,
соотношение количества потомков L с количеством элементов данных D выглядит так:

L = D + 1.

Это важнейшее соотношение определяет структуру деревьев 2-3-4. С другой стороны, листовые
деревья не имеют потомков, но могут содержать один, два или три элемента данных. Пустые
узлы запрещены.

Поскольку узлы дерева 2-3-4 могут содержать до четырех потомков, такое дерево называется
многопутевым узлом порядка 4.

Почему дерево 2-3-4 не называется деревом 1-2-3-4? Разве узел не может иметь только
одного потомка, как узлы двоичных деревьев? Двоичное дерево можно рассматривать как
многопутевое дерево порядка 2, потому что каждый узел может иметь до двух потомков.
Однако между двоичными деревьями и деревьями 2-3-4 существует важное различие (помимо
максимального количества узлов): в двоичном дереве узел может иметь до двух потомков.
Одна связь с левым или правым потомком абсолютно допустима; другая ссылка при этом равна
null .

(картинка страница 437)

В деревьях 2-3-4 узлы с одной связью невозможны. Узел с одним элементом данных всегда
должен иметь две связи (если только узел не является листовым — в этом случае он вообще
не имеет связей).

Возможные варианты представлены на рис. 10.2. Узел с двумя связями называется 2-узлом,
узел с тремя связями называется 3-узлом, а узел с четырьмя связями называется 4-узлом, но
такого понятия, как 1-узел, не существует.

8.1.3.2. Структура дерева 2-3-4
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 438)

Для удобства мы пронумеруем элементы данных в узле от 0 до 2, а ссылки на потомков — от 0
до 3, как показано на рис. 10.2. Элементы данных узла упорядочиваются по возрастанию
ключа; обычно значения располагаются слева направо.

Важным аспектом любой древовидной структуры является связь ее ссылок с ключами элементов
данных. В двоичном дереве все потомки с ключом, меньшим ключа узла, содержатся в
поддереве, корнем которого является левый потомок узла; соответственно все потомки с
ключом, большим ключа узла, содержатся в поддереве, корнем которого является правый
потомок. В дереве 2-3-4 действует тот же принцип, но в немного расширенном виде:

 - У всех потомков поддерева, корнем которого является узел 0, ключи меньше ключа 0.
 - У всех потомков поддерева, корнем которого является узел 1, ключи больше ключа 0, но
	меньше ключа 1.
 - У всех потомков поддерева, корнем которого является узел 2, ключи больше ключа 1, но
	меньше ключа 2.
 - У всех потомков поддерева, корнем которого является узел 3, ключи больше ключа 2.

Отношения наглядно представлены на рис. 10.3(страница в книге 438). Дубликаты в деревьях
2-3-4 обычно запрещены, поэтому беспокоиться о равенстве ключей при сравнении не нужно.

(картинка страница 438)

Вернемся к дереву на рис. 10.1(страница в книге 436). Как и во всех деревьях 2-3-4,
листья в нем располагаются на одном уровне (нижний ряд). Узлы верхних уровней часто
бывают неполными, то есть содержат только один или два элемента данных вместо трех.

Также заметьте, что дерево сбалансировано. Баланс сохраняется даже при вставке данных,
упорядоченных по возрастанию (или убыванию). Как вы вскоре увидите, самобалансируемость
дерева 2-3-4 обусловлена новым способом вставки данных.

8.1.3.3. Поиск в дереве 2-3-4
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 439)

Поиск элемента данных с заданным ключом напоминает поиск в двоичном дереве. Алгоритм
начинает с корня дерева и вплоть до обнаружения ключа выбирает ссылку, ведущую к поддереву
с соответствующим диапазоном значений.

Например, чтобы провести поиск элемента данных с ключом 64 в дереве на рис. 10.1(страница
в книге 436), следует начать с корня. При сравнении с корневым ключом элемент не
находится. Так как 64 больше 50, алгоритм переходит к потомку 1, которого мы обозначим
60/70/80. (Стоит напомнить, что потомок 1 является правым, потому что нумерация потомков и
связей начинается слева.) В этом узле искомый элемент также отсутствует, поэтому
необходимо перейти к следующему потомку. На этот раз 64 больше 60, но меньше 70, поэтому
алгоритм снова переходит к потомку 1. На этот раз искомый элемент находится в узле
62/64/66.

8.1.3.4. Вставка
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 439)

Новые элементы данных всегда вставляются в листьях, находящихся в нижнем ряду дерева.
Если узлы вставляются в узлах с потомками, то количество потомков необходимо изменить для
сохранения структуры дерева — согласно правилу, гласящему, что количество потомков должно
быть на единицу больше количества элементов данных в узле.

В одних случаях вставка в дереве 2-3-4 выполняется легко, в других она основательно
усложняется. Процесс всегда начинается с поиска соответствующего листового узла. Если в
процессе поиска полные узлы не обнаружены, то вставка выполняется легко — при достижении
подходящего листового узла новый элемент данных просто вставляется в него. На рис.
10.4(страница в книге 439) элемент данных с ключом 18 вставляется в дерево 2-3-4.

(картинка страница 439)

Вставка может потребовать перемещения одного или двух других элементов данных в узлах,
чтобы после вставки нового элемента ключи следовали в правильном порядке. В приведенном
примере элемент 23 сдвигается вправо, чтобы освободить место для 18.

8.1.3.5. Разбиение узлов
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 440)

Если на пути вниз к позиции вставки встречается заполненный узел, ситуация усложняется.
Такие узлы должны разбиваться; именно процесс разбиения сохраняет сбалансированность
дерева. Разновидность деревьев 2-3-4, рассматриваемых нами, часто называется нисходящими
деревьями 2­3­4, потому что узлы разбиваются в процессе перемещения вниз к позиции
вставки.

Назовем элементы данных в разбиваемом узле A , B и C . Процесс разбиения происходит
следующим образом (предполагается, что разбиваемый узел не является корневым; разбиение
корневого узла будет рассмотрено позднее).

 - Создается новый пустой узел. Он является «братом» (одноуровневым узлом) по отношению к
	разбиваемому узлу и размещается справа от него.
 - Элемент данных C перемещается в новый узел.
 - Элемент данных B перемещается в родителя разбиваемого узла.
 - Элемент данных A остается на своем месте.
 - Два правых потомка отсоединяются от разбиваемого узла и связываются с новым узлом.

Пример разбиения представлен на рис. 10.5(страница в книге 440). Разбиение также можно
описать как преобразование 4-узла в два 2-узла.

Обратите внимание: в результате разбиения узла данные смещаются направо и вверх. Такое
перемещение обеспечивает сбалансированность дерева.

В этом примере вставка требует разбиения только одного узла, но на пути к позиции вставки
может быть обнаружено несколько полных узлов. В таких ситуациях приходится выполнять
несколько разбиений.

8.1.3.6. Разбиение корневого узла
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 441)

Если в самом начале поиска позиции вставки обнаруживается полный корневой
узел, процесс разбиения несколько усложняется:

 - Создается новый корневой узел, он становится родителем разбиваемого узла.
 - Создается второй новый узел, который становится «братом» разбиваемого узла.
 - Элемент данных C перемещается в созданного «брата».
 - Элемент данных B перемещается в созданный корневой узел.
 - Элемент данных A остается на своем месте.
 - Два правых потомка отсоединяются от разбиваемого узла и связываются с новым правым
	узлом.

На рис. 10.6(страница в книге 441) показано, как происходит разбиение корневого узла.
Процесс создает новый корень, находящийся уровнем выше старого. Таким образом, общая
высота дерева увеличивается на единицу. Разбиение корня также можно описать как
преобразование 4-узла в три 2-узла.

После разбиения узла поиск позиции вставки продолжается вниз по дереву. На
рис. 10.6(страница в книге 441) элемент данных с ключом 41 вставляется в соответствующий
узел.

8.1.3.7. Разбиение при перемещении вниз
###########################(Лафоре Р. - Структуры данных и алгоритмы в Java (Классика
Computer Science). 2-е изд. - 2013.pdf страница 442)

Так как все полные узлы разбиваются при перемещении вниз, разбиение не может привести к
каскадному распространению последствий по дереву. Родитель любого разбиваемого узла
заведомо не является полным, а следовательно, может принять элемент данных B без
необходимости разбиения. Конечно, если родитель уже имеет двух потомков на момент
разбиения его потомка, он станет полным узлом, однако это означает лишь то, что он будет
разбит при следующем поиске.

На рис. 10.7(страница в книге 442) показана серия вставок в пустое дерево. Всего
выполняются четыре разбиения: два для корневого узла и два для листьев.

(картинка страница 442)

8.1.4. Деревья поиска
###########################(Методичка урока 6)
Чтобы найти заданный элемент в неупорядоченном массиве из N элементов, может понадобиться
N сравнений. Теперь предположим, что элементы массива организованы в виде специальным
образом построенного дерева, например, как показано на рисунке:

(Картинка в методичке.)

Значения, связанные с узлами дерева, по которым выполняется поиск, называются ключами этих
узлов (кроме ключа узел может содержать множество других данных). Перечислим важные
свойства дерева, показанного на рисунке:

1. Слева от каждого узла находятся узлы, ключи которых меньше или равны ключу данного
узла.
2. Справа от каждого узла находятся узлы, ключи которых больше данного узла.

Дерево, обладающее такими свойствами, называется  двоичным деревом поиска.

Например, пусть нужно найти узел, ключ которого равен 6. Начинаем поиск по дереву с корня.
Ключ корня — 8 (больше заданного), поэтому дальше нужно искать только в левом поддереве и
т.д. Если при линейном поиске в массиве за одно сравнение отсекается 1 элемент, здесь —
сразу примерно половина оставшихся. Количество операций сравнения в этом случае
пропорционально log 2 N, т.е. алгоритм имеет асимптотическую сложность O(log2 N).
Конечно, нужно учитывать, что предварительно дерево должно быть построено. Поэтому такой
алгоритм выгодно применять в тех случаях, когда данные меняются редко, а поиск
выполняется часто (например, в базах данных).

Индексация базы данных как раз и есть упорядочивание элементов с использования структур
типа двоичного дерева. В дальнейшем это позволяет сократить время поиска в базе данных.

8.2. Использование динамических структур данных
###########################(Методичка урока 6)
Поскольку двоичное дерево — это нелинейная структура данных, мы будем использовать
связанные узлы. Каждый такой узел — структура, содержащая три области: область данных,
ссылка на левое поддерево (указатель) и ссылка на правое поддерево (второй указатель).
Также иногда добавляют указатель на предыдущий узел (Parent). У листьев нет сыновей, в
этом случае в указатели будем записывать значение NULL (нулевой указатель).

Пример дерева, состоящего из пяти таких узлов:

(Картинка в методичке.)

Структура, описывающая узел дерева:

typedef  struct  Node {
T data;
 struct  Node  * left;
 struct  Node  * right;
 struct  Node  * parent;
}  Node;

8.3. Скобочная запись дерева
###########################(Методичка урока 6)
Так как изобразить дерево графически — довольно сложная задача, мы будем использовать
скобочную запись. Например, дерево, представленное на рисунке ниже, в скобочной записи
будет выглядеть следующим образом:

8(9(12(16,NULL),6),15(6(5,NULL),12))

NULL означает отсутствие узла.

(Картинка в методичке.)

// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );

			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );

			printf ( "," );

			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );

			printf ( ")" );
		}
	}
}

8.4. Рекурсивный обход двоичного дерева
###########################(Методичка урока 6)
Существует несколько способов обхода дерева:

1. КЛП — «корень–левый–правый»  (обход в прямом порядке, pre-order):
	a. Посетить корень.
	b. Обойти левое поддерево.
	c. Обойти правое поддерево.

(Картинка в методичке.)

Рекурсивное решение полностью соответствует описанию алгоритма:

void preOrderTravers ( Node * root ) {
	if  ( root ) {
		printf ( "%d " , root -> data );
		preOrderTravers ( root -> left );
		preOrderTravers ( root -> right );
	}
}

2. ЛКП — «левый–корень–правый»  (симметричный обход, in-order):
	a. Обойти левое поддерево.
	b. Посетить корень.
	c. Обойти правое поддерево.

(Картинка в методичке.)

СимметричныйОбход(Узел*)
{
	если  узел  не  пуст,  то
	{
		СимметричныйОбход(Узел->Левый)
		вывести  Узел-> data
		СимметричныйОбход(Узел->Правый)
	}
}

3. ЛПК — «левый–правый–корень»  (обход в обратном порядке, post-order):
	a. Обойти левое поддерево.
	b. Обойти правое поддерево.
	c. Посетить корень.

(Картинка в методичке.)

ОбратныйОбход(Узел*)
{
	если  узел  не  пуст,  то
	{
		ОбратныйОбход(Узел->Левый)
		ОбратныйОбход(Узел->Правый)
		вывести  Узел-> data
	}
}

Как видим, это рекурсивные алгоритмы. Они должны заканчиваться без повторного вызова,
когда текущий корень — пустое дерево.

8.5. Построение сбалансированного дерева
###########################(Методичка урока 6)
Предположим, что нужно построить дерево, значениями в узлах которого являются n чисел,
считываемых из входного файла. Чтобы сделать задачу интересней, будем строить дерево с n
узлами, имеющее минимальную высоту. Чтобы получить минимальную высоту при заданном числе
узлов, нужно размещать максимально возможное число узлов на всех уровнях, кроме самого
нижнего. Очевидно, этого можно достичь, распределяя новые узлы поровну слева и справа от
каждого узла.

Пример сбалансированного дерева на рисунке ниже:

(Картинка в методичке.)

Правило равномерного распределения при известном числе узлов n лучше всего сформулировать
рекурсивно:

1. Использовать один узел в качестве корня.
2. Построить таким образом левое поддерево с числом узлов nl=n div 2.
3. Построить таким образом правое поддерево с числом узлов nr=n-nl-1.

Это правило реализуется рекурсивной процедурой, которая читает входной файл и строит
идеально сбалансированное дерево. Дерево является идеально сбалансированным, если для
каждого узла число узлов в левом и правом поддеревьях отличается не больше, чем на 1.

(Вероятное содержимое файла data.txt
4
0 4 0 0
0 0 3 6
0 0 2 0
5 6 0 0
)

#include  <stdio.h>
#include  <malloc.h>
#include  <stdlib.h>

typedef  int T;
FILE * file;

typedef  struct  Node {
	T data;
	struct  Node  * left;
	struct  Node  * right;
}  Node;
// Построить идеально сбалансированное дерево с n узлами
Node *  Tree ( int n)
{
	Node * newNode;
	int x , nl , nr;
	if  ( n  ==  0 )
		newNode = NULL;
	else
	{
		fscanf (file, "%d", &x);
		nl = n / 2;
		nr = n - nl - 1;
		newNode = (Node*) malloc(sizeof(Node));
		newNode -> data  = x;
		newNode -> left  =  Tree ( nl );
		newNode -> right  =  Tree ( nr );
	}
	return newNode;
}
// Распечатка двоичного дерева в виде скобочной записи
void printTree ( Node  * root ) {
	if  ( root)
	{
		printf ( "%d" , root -> data );
		if  ( root -> left  || root -> right)
		{
			printf ( "(" );
			if  ( root -> left )
				printTree ( root -> left );
			else
				printf ( "NULL" );
			printf ( "," );
			if  ( root -> right )
				printTree ( root -> right );
			else
				printf ( "NULL" );
			printf ( ")" );
		}
	}
}

int main ()
{
	Node * tree  = NULL;
	file  = fopen ( "d:\\temp\\data.txt" , "r" );
	if  ( file  == NULL)
	{
		puts ( "Can't open file!" );
		return  1;
	}
	int count;
	fscanf ( file ,  "%d" ,  & count );  // Считываем количество записей
	tree  =  Tree ( count );
	fclose ( file );
	printTree ( tree );
	return  0;
}


8.6. Бинарный поиск в дереве
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu страница 319)

Деревья поиска представляют собой структуры данных, которые поддерживают многие операции
с динамическими множествами, включая Search, Minimum, Maximum, Predecessor, Successor,
Insert и Delete. Таким образом, дерево поиска может использоваться и как словарь, и как
очередь с приоритетами.

Основные операции в бинарном дереве поиска выполняются за время, пропорциональное его
высоте. Для полного бинарного дерева с n узлами эти операции выполняются за время Θ(lg n)
в наихудшем случае. Однако, если дерево представляет собой линейную цепочку из n узлов,
те же операции выполняются в наихудшем случае за время Θ(n). Как будет показано в разделе
12.4(страница в книге 332, в файле пункт 8.6.4.), математическое ожидание высоты
построенного случайным образом бинарного дерева равно O(lg n), так что все основные
операции над динамическим множеством в таком дереве выполняются в среднем за время Θ(lg
n).

На практике мы не всегда можем гарантировать случайность построения бинарного дерева
поиска, однако имеются версии деревьев, в которых гарантируется хорошее время работы в
наихудшем случае. В главе 13(страница в книге 341, в файле пункт 8.1.2.) будет
представлена одна из таких версий, а именно - красно-чёрные деревья, высота которых
составляет O(lg n).

8.6.1. Что такое бинарное дерево поиска
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu страница 319)

Как следует из названия, бинарное дерево поиска, в первую очередь, является бинарным
деревом, как показано на рис.12.1(страница 320). Такое дерево может быть представлено с
помощью связанной структуры данных, в которой каждый узел является объектом. В дополнение
к атрибуту ключа key и сопутствующим данным каждый узел содержит атрибут left, right и p,
которые указывают на левый и правый дочерний узлы и на родительский узел соотвественно.
Если дочерний или родительский узел отсутствуют, соотвествующее поле содержит значение
NIL(NULL?), - это корневой узел дерева.

Ключи в бинарном дереве поиска хранятся таким образом, чтобы в любой момент удовлетворить
следующему "свойству бинарного дерева поиска".

Пусть x представляет собой узел бинарного дерева поиска. Если y является узлом в левом
поддереве x, то y.key <= x.key. Если y является узлом в правом поддереве x, то y.key >=
x.key.

Таким образом, на рис.12.1,(а)(страница 320) ключом корня является значение 6, ключи 2, 5
и 5 в его левом поддереве не превосходят значение 6, а ключи 7 и 8 в его правом поддереве
не меньше 6. То же свойство выполняется для каждого узла дерева. Например, ключ 5 в левом
дочернем по отношению к корню узле не меньше ключа 2 в его левом поддереве и не больше
ключа 5 в его правом поддереве.

Свойство бинарного дерева поиска позволяет вывести все ключи, находящиеся в дереве, в
отсортированном порядке с помощью простого рекурсивного алгорима, называемого
"центрированным(симметричным) обходом дерева"(inorder tree walk). Этот алгоритм получил
данное название в связи с тем, что ключ в корне поддерева выводится между значениями
ключей левого поддерева и правого поддерева. Имеются и другие способы обхода, а именно -
"обход в прямом порядке"(preorder tree walk), при котором сначала выводится корень, а
затем - значения левого и правого поддеревьев, и "обходм в обратном порядке"(postorder
tree walk), когда первыми выводятся значения левого и правого поддеревьев, а уже затем -
корня. Центрированный обход бинарного дерева поиска T реализуется вызовом процедуры
Inorder-Tree-Walk(T.root).

Inorder-Tree-Walk(x)
1	if x != NIL(NULL?)
2	Inorder-Tree-Walk(x.left)
3	print x.key
4	Inorder-Tree-Walk(x.right)

В качестве примера центрированный обход деревьев, показанных на рис.12.1(страница 320),
выводит ключи в порядке 2, 5, 5, 6, 7, 8. Корректность описанного алгоритма следует по
индукцкии непосредственно из свойства бинарного дерева поиска.

Для обхода дерева с n узлами требуется время Θ(n), поскольку после начального вызова
процедура вызывается ровно два раза для каждого узла дерева: один раз - для его левого
дочернего узла и один - для правого. Приведенная далее теорема даёт нам более формальное
доказательство линейности времени центрированного обхода дерева.

Теорема 12.1
Если x - корень поддерева с n узлами, то время работы вызова Inorder-Tree-Walk(x)
составляет Θ(n).

Доказательство.
Обозначим через T(n) время, необходимое процедуре Inorder-Tree-Walk в случае вызова с
параметром, представляющим собой корень дерева с n узлами. Поскольку процедура
Inorder-Tree-Walk посещает все n узлов поддерева, мы имеем T(n) = Ω(n). Остаётся
показать, что T(n) = O(n).

Поскольку Inorder-Tree-Walk требует маленького, фиксированного количества времени для
работы с пустым деревом(для выполнения проверки x != NIL(NULL?)), мы имеем T(0) = c для
некоторой константы c > 0.

В случае n > 0 будем считать, что процедура Inorder-Tree-Walk вызывается в узле x один
раз для левого поддерева с k узлами, а второй - для правого поддерева c n - k - 1 узлами.
Таким образом, время работы процедуры Inorder-Tree-Walk(x) ограничено T(n) <= T(k) + T(n
- k - 1) + d для некоторой константы d > 0, которая отражает время, необходимое для
выполнения тела процедуры без учёта рекурсивных вызовов.

Воспользуемся методом подстановки, чтобы показать, что T(n) = O(n), путём доказательства
того, что T(n) <= (c + d)n + c. Для  n = 0 мы имеем (c + d)*0 + c = c = T(0). Для n > 0
мы имеем

T(n) <= T(k) + T(n - k - 1) + d
	= ((c + d)k + c)) + ((c + d)(n - k - 1) + c) + d
	= (c + d)n + c - (c + d) + c + d
	= (c + d)n + c ,

что и завершает доказательство.

8.6.2. Работа с бинарным деревом поиска
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu страница 322)

Наиболее частой операцией, выполняемой с бинарным деревом поиска, является поиск в нём
определённого ключа. Помимо операции Search, бинарные деревья поиска поддерживают такие
запросы, как Minimum, Maximum, Successor и Predecessor. В данном разделе мы рассмотрим
все эти операции и покажем, что все они могут быть выполнены в бинарном дереве поиска
высотой h за время O(h).

Поиск

Для поиска узла с заданным ключом в бинарном дереве поиска используется приведенная ниже
процедура Tree-Search, которая получает в качестве параметров указатель на корень
бинарного дерева и ключ k, а возвращает указатель на узел с этим ключом(если таковой не
существует, в противном случае возвращается значение NIL(NULL?)).

(картинка в книге 12.2)

Tree-Search(x, k)
1	if x == NIL(NULL?) или k == x.key
2		return x
3	if k < x.key
4		return Tree-Search(x.left, k)
5	else return Tree-Search(x.right, k)

Процедура поиска начинается с корня дерева и проходит вниз по простому пути по дереву,
как показано на рис.12.2(страница в книге 323). Для каждого встречного на пути вниз узла
x его ключ x.key сравнивается с переданным в качестве параметра ключом k. Если ключи
одинаковы, поиск завершается. Если k меньше x.key, поиск продолжается в левом поддереве
x, так как из свойства бинарного дерева поиска понятно, что искомый ключ не может
находиться в правом поддереве. Аналогично, если k больше x.key, поиск продолжается в
правом поддереве x. Узлы, которые мы посещаем при рекурсивном поиске, образуют простой
нисходящий путь от корня дерева, так что время работы процедуры Tree-Search равно O(h),
где h - высота дерева.

Ту же процедуру можно записать итеративно, "развернув" оконечную рекурсию в цикл while.
На большинстве компьютеров такая версия оказыается более эффективной.

Iterative-Tree-Search(x, k)
1	while x != NIL(NULL?) и k != x.key
2		if k < x.key
3			x = x.left
4		else x = x.right
5	return x

Минимум и максимум

Элемент с минимальным значением ключа всегда можно найти, следуя по дочерним указателям
left от корневого узла до тех пор, пока не встретится значение NIL(NULL?), как показано
на рис.12.2(страница в книге 323). Приведенная ниже процедура возвращает указатель на
минимальный элемент поддерева с корнем в данном узле x, который предпологается не равным
NIL(NULL?).

Tree-Minimum(x)
1	while x.left != NIL(NULL?)
2		x = x.left
3	return x

Свойство бинарного дерева поиска гарантирует корректность процедуры Tree-Minimum. Если у
узла x нет левого поддерева, то, поскольку все ключи в правом поддереве x не меньше ключа
x.key, минимальный ключ поддерева с корнем в узле x находится в узле x.key. Если же у
узла x есть левое поддерево, то, поскольку в правом поддереве не может быть узла с
ключом, меньшим x.key, а все ключи в узлах левого поддереване превышает x.key, узел с
минимальным значением ключа в поддереве с корнем x находится в поддереве, корнем которого
является узел x.left.

Псевдокод процедуры Tree-Maximum симметричен.

Tree-Maximum(x)
1	while x.right != NIL(NULL?)
2		x = x.right
3	return x

Обе эти процедуры находят минимальный(максимальный) элемент дерева за время O(h), где h -
высота дерева, поскольку, как и в процедуре Tree-Search, последовательность проверяемых
узлов образует простой нисходящий путь от корня дерева.

Предшествующий и последующий элементы

Иногда для заданного узла в бинарном дереве поиска требуется определить, какой узел
следует за ним в отсортированной последовательности, определяемой порядком
центрированного обхода бинарного дерева, и какой узел предшествует данному. Если все
ключи различны, последующим по отношениею к узлу x является узел с наименьшим ключом,
большим x.key. Структура бинарного дерева поиска позволяет найти этот узел, даже не
выполняя сравнение ключей. Приведенная далее процедура возвращает узел, следующий за
узлом x в бинарном дереве поиска(если таковой существует), и NIL(NULL?), если x обладает
наибольшим ключом в бинарном дереве.

Tree-Successor(x)
1	if x.right != NIL(NULL?)
2		return Tree-Minimum(x.right)
3	y = x.p
4	while y != NIL(NULL?) и x == y.right
5		x = y
6		y = y.p
7	return y

Код процедуры Tree-Successor разбивается на две части. Если правое поддерево узла x
непустое, то следующий за x элемент является крайним слева узлом в правом поддереве x,
который выявляется в строке 2 вызовом процедуры Tree-Minimum(x.right). Например, на
рис.12.2ч(страница в книге 323) следующим за узлом с ключом 15 является узел с ключом 17.

С другой стороны, если правое поддерево узла x пустое и у x имеется следующий за ним
элемент y, то y является наименьшим предком x, левый наследник которого также является
предком x. На рис.12.2(страница в книге 323) следующим за узлом с ключом 13 является узел
с ключом 15. Для того чтобы найти y, мы просто поднимаемся вверх по дереву от x до тех
пор, пока не встретим узел, который является левым дочерним узлом своего родителя. Это
действие выполняется в строках 3-7 процедуры Tree-Successor.

Время работы алгоритма Tree-Successor в дереве высотой h составляет O(h), поскольку мы
либо движемся по простому пути вниз от исходного узла, либо по простому пути вверх.
Процедура поиска предшествующего узла в дереве Tree-Predecessor симметрична процедуре
Tree-Successor и также имеет время работы O(h).

Даже если в дереве имеются узлы с одинаковыми ключами, мы можем просто определить
последующий и предшествующий узлы как такие, которые возвращаются процедурами
Tree-Successor(x) и Tree-Predecessor(x) соотвественно.

Таким образом, мы доказали следующую теорему.

Теорема 12.2

Операции Search, Minimum, Maximum, Successor и Predecessor над динамическим множеством
могут быть реализованы таким образом, что их время выполнения равно O(h) в бинарном
дереве поиска высотой h.

8.6.3. Вставка и удаление
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu страница 327)

Операции вставки и удаления приводят к внесению изменений в динамическое множество,
представленное бинарным деревом поиска. Структура данных должна быть изменена таким
образом, чтобы отражать эти изменения, но при этом сохранить свойство бинарных деревьев
поиска. Как мы увидим в этом разделе, вставка нового элемента в бинарное дерево поиска
выполняется относительно просто, однако с удалением придётся повозиться.

Вставка

Для вставки нового значения v в бинарное дерево поиска T мы Воспользуемся процедурой
Tree-Insert. Процедура получает в качестве параметра узел z, атрибуты которого z.key = v,
z.left = NIL(NULL?) и z.right = NIL(NULL?). Процедура таким образом изменяет T и
некоторые поля z, что z оказывается вставленным в корректную позицию дерева.

Tree-Insert(T, z)
1	y = NIL(NULL?)
2	x = T.root
3	while x != NIL(NULL?)
4		y = x
5		if z.key < x.key
6			x = x.left
7		elst x = x.right
8	z.p = y
9	if y == NIL(NULL?)
10		T.root = z			// Дерево T было пустым
11	elseif z.key < y.key
12		y.left = z
13	else y.right = z

На рис.12.3(страница в книге 328) показано, как работает процедура Tree-Insert. Подобно
процедурам Tree-Search и Iterative-Tree-Search, процедура Tree-Insert начинает работу с
корневого узла дерева и проходит по простому нисходящему пути. Указатель x отмечает
пусть, проходимый в поисках NIL(NULL?), который должен быть заменён входным элементом z.
Процедура поддерживает также "замыкающий указатель"(trailing pointer) y, который
представляет собой указатель на родительский по отношению к x узел. После инициализации
цикл while в строках 3-7 перемещает эти указатели вниз по дереву, перемещаясь влево и
вправо в зависимости от результата сравнения ключей z.key и x.key, до тех пор, пока x не
станет равным NIL(NULL?). Это значение находится именно в той позиции, в которую следует
поместить элемент z. Замыкающий указатель y нужен для того, чтобы знать, какой узел
должен быть изменён. В строках 8-13 выполняется установка значений указателей,
обеспечивающая вставку элемента z.

Так же, как и другие примитивные операции над бинарным деревом поиска, процедура
Tree-Insert выполняется за время O(h) в дереве высотой h.

Удаление

Стратегия удаления узла z из бинарного дерева поиска T имеет три основные ситуации; как
мы увидим, одна из ситуаций оказывается достаточно сложной.

 - Если у z нет дочерних узлов, то мы просто удаляем его, внося изменения в его
родительский узел, а именно - заменяя дочерний узел z на NIL(NULL?).
 - Если у z только один дочерний узел, то мы удаляем узел z, создавая новую связь между
родительским и дочерним узлами узла z.
 - Если у узла z два дочерних узла, то мы находим следующий за ним узел y, который должен
находиться в правом поддереве z и который занимает в дереве место z. Остаток исходного
правого поддерева z становится новым поддеревом y, а левое поддерево z становится новым
левым подддеревом y. Это самый сложный случай, поскольку, как мы увидим, здесь играет
роль, ялвяется ли y правым дочерним узлом z.

Процедура удаления данного узла z из бинарного дерева поиска T получает в качестве
аргумента указатели на T и на z. Она организована несколько иначе, чем описано ранее, и
рассматривает не три, а четыре случая, показанные на рис.12.4(страница в книге 329).

 - Если z не имеет левого дочернего узла(рис.12.4,(а)(страница в книге 329)), то мы
заменяем z его правым дочерним узлом, который может быть(или не быть) NIL(NULL?). Если
правый дочерний узел z представляет собой NIL(NULL?), то мы оказываемся в ситуации, когда
у узла z нет дочерних узлов. Если правый дочерний узел z отличен от NIL(NULL?), то мы
оказываемся в ситуации, когда у узла z имеется единственный дочерний узел, являющийся
правым дочерним узлом.

 - Если z имеет только один дочерний узел, являющийся его левым дочерним
узлом(рис.12.4,(б)(страница в книге 329)), то мы заменяем z его левым дочерним узлом.

 - В противном случае z имеет и левый, и правый дочерние узлы. Мы находим узел y,
следующий за z. Этот узел распологается в правом поддереве z и не имеет левого дочернего
узла. Мы хотим вырезать y из его текущего положения и зменить им в дереве узел z.

 - Если y является правым дочерним узлом z(рис.12.4,(в)(страница в книге 329)), то мы
заменяем z на y, оставляя нетронутым правый дочерний по отношению к y узел.

 - В противном случае y находится в правом поддереве узла z, но не является правым
дочерним узлом z(рис.12.4,(г)(страница в книге 329)). В этом случае мы сначала заменяем y
его собственным правым дочерним узлом, а затем заменяем z на y.

Для перемещения поддеревьев в бинарном дереве поиска мы определяем подпрограмму
Transplant, которая заменяет одно поддерево, являющееся дочерним по отношению к своему
родителю, другим поддеревом. Когда Transplant заменяет поддерево с корнем в узле u
поддеревом с корнем в узле v, родитель узла u становится родителем узла v, который
становится соответствующим дочерним узлом родительского по отношению к u узла.

Transplant(T, u, v)
1	if u.p = NIL(NULL?)
2		T.root = v
3	elseif u == u.p.left
4		u.p.left = v
5	else u.p.right = v
6	if v != NIL(NULL?)
7		v.p = u.p

В строках 1 и 2 обрабатывается случай, когда u является корнем T. В противном случае u
является либо левым, либо правым дочерним узлом своего родителя. В строках 3 и 4
выполняется обновление u.p.left, если u является левым дочерним узлом, в строке 5
обновляется u.p.right, если u является левым дочерним узлом. Мы допускаем значение
NIL(NULL?) для узла v, и строка 6 и 7 обновляет v.p, если v не NIL(NULL?). Заметим, что
Transplant не пытается обновлять v.left и v.right; выполнение этих действий(или их не
выполнение) находится в зоне отвественности вызывающей подпрограмму Transplant процедуры.

Имея подпрограмму Transplant, мы можем реализовать процедуру удаления узла z из бинарного
дерева поиска T следующим образом.

Tree-Delete(T, z)
1	if z.left == NIL(NULL?)
2		Transplant(T, z, z.right)
3	elseif z.right == NIL(NULL?)
4		Transplant(T, z, z.left)
5	else y = Tree-Minimum(z.right)
6		if y.p != z
7			Transplant(T, y, y.right)
8			y.right = z.right
9			y.right.p = y
10		Transplant(T, z, y)
11		y.left = z.left
12		y.left.p = y

Процедура Tree-Delete работает следующим образом. Строки 1 и 2 обрабатывают случай,
когда у узла z нет левого дочернего узла, а строки 3 и 5 - когда у z есть левый дочерний
узел, но нет правого. Строки 5-12 работают с оставшимися двумя случаями, когда у z есть
два дочерних узла. Строка 5 находит узел y, следующий за z. Поскольку z имеет непустое
правое поддерево, следующий за z узел должен быть узлом этого поддерева с наименьшим
ключом; поэтому поиск узла y осуществляется вызовом Tree-Minimum(z.right). Как отмечалось
ранее, у y нет левого дочернего узла. Мы хотим вырезать y из его текущего положения,
после чего этот узел должен заменить в дереве узел z. Если y является правым дочерним
узлом z, то строки 10-12 заменяют z как дочерний узел его родителя на y и заменяют левый
дочерний узел y левым дочерним узлом z. Если y не является правым дочерним узлом z, в
строках 7-9 выполняется замена y как дочернего узла своего родителя правым дочерним по
отношению к y узлом, и преобразование правого дочернего узла z в правый дочерний узел y,
после чего строки 10-12 заменяют z как дочерний узел его родителя узлом y, а левым
дочерним узлом y становится левый дочерний узел z.

Каждая строка Tree-Delete, включая вызовы Transplant, выполняется за константное время,
за исключением вызова Tree-Minimum в строке 5. Таким образом, Tree-Delete выполняется за
время O(h) в дереве высотой h.

Таким образом, доказана следующая теорема.

Теорема 12.3

Операции над динамическим множеством Insert и Delete можно реализовать таким образом, что
каждая из них выполняется в бинарном дереве поиска высотой h за время O(h).

8.6.4. Случайное построение бинарных деревьев поиска
###########################(Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы.
Построение и анализ. - 2013.djvu страница 332)

Мы показали, что все базовые операции с бинарными деревьями поиска имеют время выполнения
O(h), где h - высота дерева. Однако при вставке и удалении элементов высота дерева
меняется. Если, например, все элементы вставляются в дерево в строго возрастающей
последовательности, то такое дерево вырождается в дерево в строго возрастающей
последовательности, то такое дерево вырождается в цепочку высотой n - 1. С другой
стороны h >= [lg n]. Как и в случае быстрой сортировки, можно показать, что поведение
алгоритма в среднем случае гораздо ближе к наилучшему случаю, чем к наихудшему.

К сожалению, в ситуации, когда при форматировании бинарного дерева поиска используются и
вставки, и удаления, о средней высоте образующихся деревьев известно мало, так что мы
ограничимся анализом ситуации, когда дерево строится только с использованием вставок, без
удаленией. Определим "случайно построенное бинарное дерево поиска"(randomly built binary
search tree) с n ключами как дерево. которое возникает при вставке ключей в изначально
пустое дерево в случайном порядке, когда все n! перестановок входных ключей
равновероятны.

8.7. Пирамидальная сортировка (Heap sort)
###########################(Из методички 8)
Сначала проведем необходимую подготовительную работу. Рассмотрим ряд чисел, расположенных
следующим образом:

(картинка в методичке)

Если пронумеровать числа ai(i - нижний индекс), так, как это сделано на рисунке (номер
указан в скобках), то нетрудно увидеть, что ai(i - нижний индекс) <= a​2i(2i - нижний
индекс) и ai(i - нижний индекс)<= a2i + 1(2i + 1 - нижний индекс) для всякого i = 1, 2,
..., n / 2, где n — количество чисел. В дальнейшем числа a2i(2i - нижний индекс)​ и a2i
+1(2i + 1 - нижний индекс)мы будем называть «потомками» числа ai(i - нижний индекс).

Последовательность чисел, подчиняющихся указанному условию, мы будем называть
«пирамидой». Очевидно, что на вершине пирамиды находится минимальный элемент.
Это обстоятельство приводит к мысли о возможности сортировки чисел в пирамиде следующим
способом. Можно взять число с вершины и разместить его на последнем месте в пирамиде,
а число, находившееся на этом месте, расположить так, чтобы числа без этого
первого минимума также составляли пирамиду (чтобы и для них соблюдалось указанное
условие).

В результате переразмещения всех элементов на вершине пирамиды опять окажется минимальное
из всех чисел (без учета первого минимума). После этого новый минимум с вершины
располагается на предпоследнем месте, а находившееся там число перемещается в другое
(соответствующее ему) место в новой пирамиде. При этом на вершине вновь окажется
очередной минимальный элемент. В результате многократного повторения указанных действий
вся последовательность чисел, взятых из пирамиды, будет упорядочена.

Из сказанного следует, что нам необходимо уметь располагать какое-то число так, чтобы
вновь получилась пирамида. Это можно сделать, поместив требуемое число сначала в вершину
пирамиды, а затем, сравнивая это число с его «потомками», опускать его по пути, на котором

(картинка в методичке)

находятся меньшие по сравнению с ним числа (которые одновременно поднимаются вверх).
Процесс прекращается, когда встретятся «потомки», большие или равные размещаемому
числу.

(картинка в методичке)

Для хранения двоичного дерева будем использовать массив (см. урок двоичные деревья).

