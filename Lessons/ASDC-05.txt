5. Рекурсия, рекурсивные алгоритмы
	5.1. Треугольные числа
	5.2. Факториал
	5.3. Числа Фибоначчи
	5.4. Анаграммы
	5.5. Ханойская башня
	5.6. Поиск с возвратом
		5.6.1. Задача о 8 ферзях
		5.6.2. Обход шахматной доски конем
        5.7. Поиск всех возможных вариантов
		5.7.1. Поиск наибольшей общей подпоследовательности
		5.7.2. Поиск маршрутов шахматного короля


Коллеги здравствуйте! На этом уроке мы познакомимся с таким понятием как рекурсия, изучим рекурсивные алгоритмы, а также …


/////////5. Рекурсия, рекурсивные алгоритмы
Итак, что же такое рекурсия. Рекурсией называется механизм работы программы, в котором для решения задачи из подпрограммы (функции) вызывается та же самая функция. Если функция делает это непосредственно, то рекурсия называется прямой, если через другую функцию – косвенной. Она также может быть единичной (однократный вызов) либо множественной (вызов осуществляется несколько раз).
На первый взгляд понятие кажется несколько сложным, поскольку человек не мыслит рекурсивно. Например, занимаясь покраской забора, вы, скорее всего, начнете с одного края и будете двигаться к другому. Вряд ли вам придет в голову разделить забор на две части (левую и правую), а затем красить каждую половину.
Тем не менее, есть задачи, которые рекурсивны по своей природе, а их структура и решение легко отслеживаются с помощью алгоритма. Таковы, например, программы, выстраивающие деревья и проводящие по ним поиск, о чем мы с вами будем говорить на следующих занятиях.
Рекурсия является альтернативой циклам и в некоторых случаях позволяет реализовать весьма интересные алгоритмы решения задачи.
Давайте разберем на примере. Напишем программу вывода в консоль чисел от a до b с использованием рекурсивного алгоритма.
void loop ( int a , int b) {      // объявим функцию петля, на вход которой передаем диапазон
printf ( "%5d" , a ); // выведем в консоль а
if ( a < b )               // напишем условие выхода из рекурсивного вызова
loop ( a + 1 , b );   // и собственно сам рекурсивный вызов
}
int main ( int argc , char * argv []) {
loop ( 0 , 10 );     // вызовем нашу рекурсивную функцию
return 0;
}
	А теперь разберем как это работает. При каждом рекурсивном вызове функции значение а будет увеличиваться на 1 и сравниваться с b. Как только условие оператора if станет ложным, рекурсивный вызов будет завершен.
Можно добавить картинку с объяснением погружения и выхода наверх.
С рекурсией нужно быть осторожным, так как она может породить большое количество вызовов функций, поэтому условие выхода из рекурсивного вызова пишется в первую очередь.
	Рассмотрим еще один пример нахождения суммы цифр числа. Для этого нам потребуется вначале получить эти цифры, а затем их просуммировать. Получить последнюю цифру числа можно, если найти остаток от деления числа на 10. В связи с этим для разложения числа А на составляющие его цифры можно использовать следующий алгоритм:
1. Находим остаток при делении числа А на 10, т.е. получаем крайнюю правую цифру числа.
2. Находим целую часть числа при делении A на 10, т.е. отбрасываем от числа A крайнюю правую цифру.
3. Если преобразованное A > 0, то переходим к пункту 1. Иначе число равно нулю, и отделять от него больше нечего.


Напишем нерекурсивный способ. 
int sumDigit ( long a) { // объявим функцию 
int s = 0;                     // объявим переменную в которую будем складывать результат
while ( a > 0) {           // напишем цикл, с условием выхода а == 0
s = s + a % 10;// на каждой итерации получаем крайнюю правую цифру и прибавляем к результату
a = a / 10;       // отбрасываем крайнюю правую цифру
}
return s;
}

int main ( int argc , char * argv []) { 
int n;
printf ( "Input number: " ); 
scanf ( "%d" , & n );   // запросим у пользователя число
printf ( "Summ digit: %d" , sumDigit ( n )); // выведем в консоль результат работы нашей функции, в которую передадим полученное число
return 0;
}

А теперь решим ту же задачу, но с применением рекурсии. Для этого нам понадобится составить рекуррентное соотношение. Вообще, практически любой метод можно преобразовать в рекурсивный, если выявить рекуррентное соотношение между вычисляемыми в методе значениями и любой рекурсивный метод можно преобразовать в обычный.
Дадим общее определение рекуррентному соотношению. Рекуррентное соотношение — формула вида an = f(n, an-1, an-2,… an-p), выражающая каждый член последовательности an через p предыдущих членов и возможно номер члена последовательности n, т.е. имеется однозначная зависимость между членами последовательности.
Для нашей задачи рекуррентное соотношение будет выглядеть следующим образом:
S(N) = 0, при N = 0
S(N) = S(N / 10) + N % 10, при N > 0
	Здесь N – это наше число А, а S(N) – результат суммирования цифр этого числа, зависящий от А. Т.е. первая запись говорит нам что если, число А = 0, то и результат будет равен 0. Вторая запись описывает как результат зависит от А. 
Давайте напишем реализацию:
int sumDigit ( long a) {
if ( a == 0 )
return 0;
else
return sumDigit ( a / 10 ) + a % 10;
}
int main ( int argc , char * argv []) {
int n;
printf ( "Input number: " );
scanf ( "%d" , & n );
printf ( "Summ digit: %d" , sumDigit ( n ));
return 0;
}
Обратите внимание, здесь нет явного условия выхода из рекурсивного вызова, но т.к. при целочисленном делении а обратится в 0, алгоритм обязательно закончит своё выполнение.

///////////5.1. Треугольные числа 
Теперь рассмотрим такое понятие как треугольные числа. 
Треугольное число - это число точек, которые могут быть расставлены в форме правильного треугольника (рисунок). Очевидно, с чисто арифметической точки зрения, n-е треугольное число - это сумма n первых натуральных чисел. Последовательность треугольных чисел Тn, где n = 0, 1, 2… начинается так: 0, 1, 3, 6, 10, 15, 21….
Т.е.:
1 = 1
3 = 1+2
6 = 1+2+3
10 = 1+2+3+4
15 = 1+2+3+4+5
….
Эта закономерность сохраняется и дальше. Соответственно можно вывести формулу для получения треугольных чисел Тn = 1+2+3+…+n. На вид очень просто, но не годится для вычислений, поэтому запишем ее так:
Тn = 1/2n(n+1)
Например, 2016 — это треугольное число: T63=(63 * 64) / 2 = 2016.
Рекуррентная формула для n-го треугольного числа:
Tn=T(n-1) + n.
Давайте напишем программу, которая будет находить треугольные числа и выводить их в консоль: 

#include <stdio.h>
int triangle (int n) {
    if (n == 1)
        return 1;
    else
        return n + triangle(n - 1);
}

void printPyramid (int n) {
    int i = 1;
    while (i <= n) {
        int amnt = i;
        char shift[5];
        sprintf(shift, "%%%dd", n + 1 - i);
        printf(shift, i);
        while (--amnt != 0) {
            printf(" %d", i);
        }
        printf("\n");
        i++;
    }
}

void printTriangle (int n) {
    int prev = 0;
    while (n > 0) {
        prev++;
        n -= prev;
        printf("%s%d", (prev > 1) ? " + " : "", prev);
    }
    printf("\n");
}

int main (int argc, const char* argv[]) {
    printPyramid(5);
    printTriangle(triangle(5));
    printf("%d", triangle(5));
}

////////////5.2. Факториал 
Переходим к факториалам числа. Немного вспомним математику и напишем:
3! = 3*2*1*1 – факториал числа 3 равен произведению 1 на 2 и на 3. Почему 1 мы записали два раза, это не ошибка и мы сейчас в этом убедимся. Запишем рекуррентное соотношение для факториала числа:
N! = N*(N-1)!
	0! = 1;
т.е. факториал числа равен самому числу, умноженному на факториал предыдущего числа. Факториал 0 равен 1. Тогда расчет 3! будет выглядеть так:
3! = 3*2! = 3*2*1! = 3*2*1*0! = 3*2*1*1.
Давайте напишем это в коде.
 int factorial( int a) {
if ( a == 0 ) 
return 1;
else
return a*factorial(a-1);
}
int main ( int argc , char * argv []) {
int n;
printf ( "Input number:" );
scanf ( "%d" , & n );
printf ( "Summ digit:%d" , factorial( n ));
return 0;
}
Как и в предыдущем примере, условием выхода из рекурсивного вызова будет а = 0. 
Обратите внимание на недостаток этого алгоритма, если вызвать функцию factorial с параметром -1, рекурсия никогда не остановится. 
-1! = -1*-2! = -1*-2*-3! = -1*-2*-3*-4!....
Чтобы этого избежать, изменим условие оператора if на а <= 0, функция не будет считать факториалы отрицательных чисел, но и выполнятся бесконечно тоже не будет. 
Теперь можем сделать важный вывод – рекурсия должна быть конечной. Всегда при написании рекурсивных методов необходимо следить за выходом из рекурсивного вызова.
Немного отвлечемся и поговорим стеке вызовов. Для работы программы в памяти компьютера выделяются две области памяти: стек и хип (куча). Когда часть кода вызывает функцию, информация о вызове находится в стеке. Как только функция завершает работу - информация из стека выталкивается и программа возобновляет свою работу с места, на котором остановилась. Список вызовов функций называется стеком вызова. 
Рекурсивные методы обладают количественной мерой – глубиной. Глубиной рекурсии называется максимальное число вложенных рекурсивных вызовов. Так вот иногда может возникать  очень глубокая рекурсия, что приводит к большому расходу стекового пространства, вплоть до его переполнения со всеми вытекающими последствиями, и зависанию программы. 

//////////////// 5.3. Числа Фибоначчи
Далее рассмотрим числа Фибоначчи.
Числа Фибоначчи это элементы числовой последовательности вида:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34…
т.е. в ней первые два числа равны либо 1 и 1, либо 0 и 1, а каждое последующее число равно сумме двух предыдущих. Названы в честь средневекового математика Леонардо Пизанского, известного как Фибоначчи.
Давайте напишем рекуррентное соотношение последовательности {Fn}:
F0 = 0,
F0 = 1,
Fn = Fn-1 + Fn-2 для n > 1
Согласно нашему рекуррентному соотношению напишем алгоритм:
int long fib ( int n) { // объявим функцию fib которая возвращает long 
if ( n == 0 ) return 0; // первое условие
if ( n == 1 ) return 1; // второе условие
return fib ( n - 1 ) + fib ( n - 2 ); // и собственно реализация третьего условия
}
int main ( int argc , char * argv [])
{
int i;
for ( i = 0 ; i < 20 ; i ++) // напишем цикл от 0 до 20, вызовем в нем нашу функцию 
printf ( "%d " , fib ( i )); // и передадим ей в качестве аргумента i.
return 0;
}
Приведенный алгоритм достаточно прост для понимания, но работает довольно медленно. Например для расчета значения fib(6) программе потребуется определить значения fib(5) и fib(4), но перед расчетом fib(5) ей потребуется определить значения fib(4) и fib(3), т.е. fib(4) будет определяться дважды. При больших значениях n рекурсия fib(n) становится достаточно глубокой, а одни и те же значения приходится находить большое количество раз. 

/////////////5.4. Анаграммы
Анаграмма — это игра со словами, когда в результате перестановки букв слова или фразы получаем другое слово или фразу. Два слова являются анаграммами, если мы можем получить одно из другого переставляя буквы местами.
Допустим, у нас есть некий машинный алфавит и в нем всего четыре буквы «m», «o», «r», «e». Нам нужно получить все слова из этих букв. Количество букв обозначим len. Будем определять буквы слова последовательно, одну за другой. Первая буква может быть любой из четырех. Предположим что сначала поставим «m». Тогда, чтобы получить все варианты с первой буквой «m», нужно перебрать все возможные комбинации букв, оставшихся len-1 позиций. Далее ставим на первое место остальные буквы, при этом повторяя процедуру перебора.
w[0] = ’m’; //перебор последних символов без первого
w[0] = ’o’; //перебор последних символов без первого
w[0] = ’r’; //перебор последних символов без первого
w[0] = ’e’; //перебор последних символов без первого
т.е. задача длины len сведена к четырем задачам длины len-1.
Давайте рассмотрим на примере:
#include <stdio.h>
#define size 3
char arr[64];

void rotate(int newSize) {
    int i;
    int pos = size - newSize;
    char temp = arr[pos];
    for (i = pos + 1; i < size; i++) {
        arr[i - 1] = arr[i];
    }
    arr[i - 1] = temp;
}

void display() {
    for (int i = 0; i < size; i++) {
        printf("%c", arr[i]);
    }
    printf("\n");
}

void getAnagramm(int newSize) {
    if (newSize == 1)
        return;
    for (int i = 0; i < newSize; i++) {
        getAnagramm(newSize - 1);
        if (newSize == 2)
            display();
        rotate(newSize);
    }
}

int main() {
    printf("Введите слово из %d букв: ", size);
    scanf("%s", arr);
    display(arr);
    getAnagramm(size);

    return 0;
}
////////////5.5. Ханойская башня
	Ханойская башня это задача в которой дано три стержня, на один из которых нанизано 8 колец, меньшее на большем. Нужно перенести все кольца на другой стержень за наименьшее количество ходов, причём можно за один ход брать только одно кольцо, и нельзя класть большее кольцо на меньшее. Классическая задача рекурсии. Нам нужно научиться перекладывать одно кольцо на другой стержень, а затем поставить перед собой задачу - переложить n-1 колец на временный стержень, переложить то самое одно кольцо на конечный, и затем переложить n-1 колец со временного на конечный. 
Заведём счётчик операций, для того чтобы немного отформатировать вывод, и вообще для интереса. Напишем функцию, которая будет говорить нам с какого на какой стержень надо переложить кольцо. и основную функцию, которая будет решать поставленную пару минут назад задачу

#include <stdio.h>

int operations = 0;
void put(int from, int to) {
    printf("%d -> %d | ", from, to);
    if ((++operations % 5) == 0) printf("\n");
}

void hanoi(int from, int to, int n) {
    int temp = from ^ to; // 01^10=11 10^11=01 11^01=10
    if (n == 1) {
        put(from, to);
    } else {
        hanoi(from, temp, n - 1);
        put(from, to);
        hanoi(temp, to, n - 1);
    }
}

int main() {
    int disks = 3;
    printf("pyramid size = %d \n", disks);
    hanoi(1, 3, disks);
    printf("operations = %d", operations);
    return 0;
}
Вот и всё решение. Обратите внимание на то, что мы, написав рекурсивную функцию, решаем задачу абстрактно, не задумываясь о том как именно переложить пятое или седьмое или третье кольцо. Это делается аналогично предыдущим кольцам. Взяли н-1 как то откинули (а как? взяли н-минус-ещё-1, а их как? взяли н-1-1-1... и так пока н не будет == 1) взяли одно кольцо, переместили, и затем взяли н-1 колец и положили на нужное место.

//////////////5.6. Поиск с возвратом
Это такой поиск, когда мы ищем некое решение методом перебора. И если сделав очередной ход этого перебора обнаруживаем себя в тупике - возвращаемся на шаг назад и ищем другое решение. 
//////////////5.6.1. Задача о 8 ферзях
Классическим примером задач на поиск с возвратом является задача о восьми ферзях, где необходимо расставить на шахматной доске 8 ферзей так чтобы они не находились под боем друг друга.
// 0 - клетка пустая
#define X 8
#define Y 8
#define QUEENS 8

int board[Y][X];

void annull(int arr[Y][X]) {
	int i;
	int j;
	for (i = 0; i < Y; i++)
		for (j = 0; j < X; j++)
			arr[i][j] = 0;
}

void printBoard(int arr[Y][X]) {
	int i;
	int j;
	for (i = 0; i < Y; i++) {
		for (j = 0; j < X; j++)
			printf("%3d", arr[i][j]);
		printf("\n");
	}
}
int checkQueen(int x, int y) {
    int i;
	int j;
	for(i = 0; i < Y; i++)
        for(j = 0; j < X; j++)
          if (board[i][j] != 0) // Если нашли фигуру
              if (!(i == x && j == y)) {// Если это не наша фигура
                  // Лежат на одной вертикали или горизонтали
                  if (i - x == 0 || j - y == 0) return 0;
				  // Лежат на одной диагонали
                  if (abs(i - x) == abs(j - y)) return 0;
              }
	// Если дошли сюда, то всё в порядке
	return 1;
}

int checkBoard() {
	int i;
	int j;
	for (i = 0; i < Y; i++)
		for (j = 0; j < X; j++)
			if (board[i][j] != 0)
				if (checkQueen(i, j) == 0)
					return 0;
	return 1;
}

int queens(int n) {
	if (checkBoard() == 0) return 0;
	if (n == QUEENS + 1) return 1;
	int col;
	int row;
	for (row = 0; row < Y; row++)
		for (col = 0; col < X; col++) {
			if (board[row][col] == 0) {
				board[row][col] = n;
				if (queens(n + 1))
					return 1;
				board[row][col] = 0;
			}
		}
	return 0;
}

int main(int argc, char *argv[]) {
	annull(board);
	queens(1);
	printBoard(board);
}

//////////////5.6.2. Обход шахматной доски конем
Требуется обойти конём шахматную доску размером 8х8, пройдя через все поля доски по одному разу. Здесь алгоритм решения такой же как и в задаче о 8 ферзях.

#include <stdio.h>
const int He = 8;
const int Wi = 8;

int desk[He][Wi];
int possible[][2] = {
        {-2, 1}, {-1, 2}, {1, 2}, {2, 1},
        {2, -1}, {1, -2}, {-1, -2}, {-2, -1} };
int maxMoves = He * Wi - 1;

int isPossible(int x, int y){
    return x >= 0 && x < He && y >= 0 && y < Wi && desk[x][y] == 0;
}

void printDesk(){
    printf("\n");
    for (int i = 0; i < He; i++) {
        for(int j = 0; j < Wi; j++)
            printf("%3d ", desk[i][j]);
        puts("");
    }
}

int knightMove(int currentX, int currentY, int move){
    int nextX, nextY;
    desk[currentX][currentY] = move;
    if (move > maxMoves) return 1;

    for (int i = 0; i < 8; i++) {
        nextX = currentX + possible[i][1];
        nextY = currentY + possible[i][0];
        if (isPossible(nextX, nextY) && knightMove(nextX,nextY, move + 1))
            return 1;
    }

    desk[currentX][currentY] = 0;
    return 0;
}


int main() {
    knightMove(1, 0, 1);
    printDesk();
    return 0;
}

//////////////5.7. Поиск всех возможных вариантов
А теперь на примере наибольшей общей подпоследовательности и шахматном короле рассмотрим алгоритмы поиска маршрутов.

//////////////5.7.1. Поиск наибольшей общей подпоследовательности
Определение - некая последовательность является подпоследовательностью какой-то другой последовательности, если существует строго возрастающая последовательнось индексов обеих последовательностей. то есть например последовательность bcdb является подпоследовательностью подследовательности abcbdab, а соответствующая последовательность индексов имеет вид 2-3-5-7. Задача поиска наибольшей общей подпоследовательности является классической задачей программирования. 
	Итак пусть имеются последовательности x(1...n) и y(1...m) необходимо найти НОП(х, у). Подумаем о рекуррентном соотношении:
LCS(x, y) = 0, if x = 0 or y = 0;
LCS(x, y) = LCS(x - 1, y - 1) + 1, if x[i] == y[i];
LCS(x, y) = max of (LCS(x, y-1), LCS(x-1, y)), if x[i] != y[i];
и реализуем его на языке С

#include <stdio.h>
#include <math.h>

int lcs_length(char * A, char * B)
{
	if (*A == '\0' || *B == '\0')
		return 0;
	else if (*A == *B)
		return 1 + lcs_length(A+1, B+1);
	else
	{
		int x1 = lcs_length(A + 1, B);
		int x2 = lcs_length(A, B + 1);
		return (x1 > x2) ? x1 : x2;
	}
}


int main() {
	char* x = "abcdef";
	char* y = "abef";
	printf("result = %d ", lcs_length(x, y));
	getchar();
	getchar();
	return 0;
}

/////////////////5.7.2. Поиск маршрутов шахматного короля
Поставим себе задачу - подсчитать возможное количество маршрутов шахматного короля из левого-верхнего угла поля в правый-нижний. Потом расскажу как добавить туда возможность обходить условные препятствия. Эти алгоритмы могут пригодиться уже и на высоких уровнях, для написания, например, игр, похожих на разного рода шарики-пузырики. 
==========рисовать============
Итак что мы имеем: за один ход король может сдвинуться на одну клетку, либо вниз, либо вправо, мы же хотим найти только кратчайшие пути, правда? Стартуем в точке r=0, c=0, и будем обозначать r - строки, а с - столбцы. Условимся, что строки будем нумеровать сверху вниз от нуля до n-1, а столбцы - слева направо, от нуля до m-1. Пусть ROUTE(r, c) это количество маршрутов, ведущих в клетку r, c из начальной. Непосредственно в эту клетку можно попасть, очевидно, из клетки (r-1, c) или из клетки (r, c-1). Получаем рекуррентное соотношение: возможное количество маршрутов, ведущих в клетку (r, c) равно сумме всех возможных количеств маршрутов, ведущих в клетку слева и в клетку сверху от неё. Запишем это так:
ROUTE(r, c) = ROUTE(r - 1, c) + ROUTE(r, c - 1).
Далее думаем, если клетка расположена на строке 0, значит это самая верхняя клетка, и попасть в неё можно только одним путём, двигаясь вправо. Поэтому ROUTE(0, c) = 1 для всех возможных с. Аналогично ROUTE(r, 0) = 1 для всех возможных r.
    int A[N][M];
    int i,j;
    A[0][0] = 0;
    for(i = 1; i < N; i++) {
        A[i][0] = 1;
        for(j = 1; j < M; j++){
            A[0][j] = 1;
            A[i][j] = A[i][j-1] + A[i-1][j];
        }
    }  
После чего мы можем вывести наш двумерный массив в консоль и увидеть, что рекуррентное соотношение - это не обязательно должна быть рекурсивная функция. 
int routes(int x, int y) {
    if (x == 0 && y == 0)
        return 0;
    else if (x == 0 ^ y == 0)
        return 1;
    else
        return routes(x, y - 1) + routes(x - 1, y);
}

int main() {
    const int sizeX = 5;
	const int sizeY = 5;
	int i;
	int j;

	for (i = 0; i < sizeY; i++) {
		for (j = 0; j < sizeX; j++) {
			printf("%6d ", routes(j, i));
		}
		printf("\n");
	}
    return 0;
}