//5. Рекурсия, рекурсивные алгоритмы
//	5.1. Рекурсия, определение, примеры
//      5.2. Треугольные числа
//	5.3. Факториал
//	5.4. Числа Фибоначчи
//	5.5. Анаграммы
//	5.6. Ханойская башня
//	5.7. Поиск последовательности (наибольшая общая подпоследовательность)

Коллеги здравствуйте! На этом уроке мы познакомимся с таким понятием как рекурсия, изучим рекурсивные алгоритмы, а также …


/////////5.1 Итак, что же такое рекурсия. Рекурсией называется механизм работы программы, в котором для решения задачи из подпрограммы (функции) вызывается та же самая функция. Если функция делает это непосредственно, то рекурсия называется прямой, если через другую функцию – косвенной. Она также может быть единичной (однократный вызов) либо множественной (вызов осуществляется несколько раз).
На первый взгляд понятие кажется несколько сложным, поскольку человек не мыслит рекурсивно. Например, занимаясь покраской забора, вы, скорее всего, начнете с одного края и будете двигаться к другому. Вряд ли вам придет в голову разделить забор на две части (левую и правую), а затем красить каждую половину.
Тем не менее, есть задачи, которые рекурсивны по своей природе, а их структура и решение легко отслеживаются с помощью алгоритма. Таковы, например, программы, выстраивающие деревья и проводящие по ним поиск, о чем мы с вами будем говорить на следующих занятиях.
Рекурсия является альтернативой циклам и в некоторых случаях позволяет реализовать весьма интересные алгоритмы решения задачи.
Давайте разберем на примере. Напишем программу вывода в консоль чисел от a до b с использованием рекурсивного алгоритма.
void loop ( int a , int b) {      // объявим функцию петля, на вход которой передаем диапазон
printf ( "%5d" , a ); // выведем в консоль а
if ( a < b )               // напишем условие выхода из рекурсивного вызова
loop ( a + 1 , b );   // и собственно сам рекурсивный вызов
}
int main ( int argc , char * argv []) {
loop ( 0 , 10 );     // вызовем нашу рекурсивную функцию
return 0;
}
	А теперь разберем как это работает. При каждом рекурсивном вызове функции значение а будет увеличиваться на 1 и сравниваться с b. Как только условие оператора if станет ложным, рекурсивный вызов будет завершен.
Можно добавить картинку с объяснением погружения и выхода наверх.
С рекурсией нужно быть осторожным, так как она может породить большое количество вызовов функций, поэтому условие выхода из рекурсивного вызова пишется в первую очередь.
	Рассмотрим еще один пример нахождения суммы цифр числа. Для этого нам потребуется вначале получить эти цифры, а затем их просуммировать. Получить последнюю цифру числа можно, если найти остаток от деления числа на 10. В связи с этим для разложения числа А на составляющие его цифры можно использовать следующий алгоритм:
1. Находим остаток при делении числа А на 10, т.е. получаем крайнюю правую цифру числа.
2. Находим целую часть числа при делении A на 10, т.е. отбрасываем от числа A крайнюю правую цифру.
3. Если преобразованное A > 0, то переходим к пункту 1. Иначе число равно нулю, и отделять от него больше нечего.


Напишем нерекурсивный способ. 
int sumDigit ( long a) { // объявим функцию 
int s = 0;                     // объявим переменную в которую будем складывать результат
while ( a > 0) {           // напишем цикл, с условием выхода а == 0
s = s + a % 10;// на каждой итерации получаем крайнюю правую цифру и прибавляем к результату
a = a / 10;       // отбрасываем крайнюю правую цифру
}
return s;
}

int main ( int argc , char * argv []) { 
int n;
printf ( "Input number:" ); 
scanf ( "%d" , & n );   // запросим у пользователя число
printf ( "Summ digit: %d" , sumDigit ( n )); // выведем в консоль результат работы нашей функции, в которую передадим полученное число
return 0;
}

А теперь решим ту же задачу, но с применением рекурсии. Для этого нам понадобится составить рекуррентное соотношение. Вообще, практически любой метод можно преобразовать в рекурсивный, если выявить рекуррентное соотношение между вычисляемыми в методе значениями и любой рекурсивный метод можно преобразовать в обычный.
Дадим общее определение рекуррентному соотношению. Рекуррентное соотношение — формула вида an = f(n, an-1, an-2,… an-p), выражающая каждый член последовательности an через p предыдущих членов и возможно номер члена последовательности n, т.е. имеется однозначная зависимость между членами последовательности.
Для нашей задачи рекуррентное соотношение будет выглядеть следующим образом:
S(N) = 0, при N = 0
S(N) = S(N / 10) + N % 10, при N > 0
	Здесь N – это наше число А, а S(N) – результат суммирования цифр этого числа, зависящий от А. Т.е. первая запись говорит нам что если, число А = 0, то и результат будет равен 0. Вторая запись описывает как результат зависит от А. 
Давайте напишем реализацию:
int sumDigit ( long a) {
if ( a == 0 )
return 0;
else
return sumDigit ( a / 10 ) + a % 10;
}
int main ( int argc , char * argv []) {
int n;
printf ( "Input number:" );
scanf ( "%d" , & n );
printf ( "Summ digit:%d" , sumDigit ( n ));
return 0;
}
Обратите внимание, здесь нет явного условия выхода из рекурсивного вызова, но т.к. при целочисленном делении а обратится в 0, алгоритм обязательно закончит своё выполнение.

///////////5.2 Теперь рассмотрим такое понятие как треугольные числа. 
Треугольное число - это число точек, которые могут быть расставлены в форме правильного треугольника (рисунок). Очевидно, с чисто арифметической точки зрения, n-е треугольное число - это сумма n первых натуральных чисел. Последовательность треугольных чисел Тn, где n = 0, 1, 2… начинается так: 0, 1, 3, 6, 10, 15, 21….
Т.е.:
1 = 1
3 = 1+2
6 = 1+2+3
10 = 1+2+3+4
15 = 1+2+3+4+5
….
Эта закономерность сохраняется и дальше. Соответственно можно вывести формулу для получения треугольных чисел Тn = 1+2+3+…+n. На вид очень просто, но не годится для вычислений, поэтому запишем ее так:
Тn = 1/2n(n+1)
Например, 2016 — это треугольное число: T63=(63 * 64) / 2 = 2016.
Рекуррентная формула для n-го треугольного числа:
Tn=T(n-1) + n.
Давайте напишем программу, которая будет находить треугольные числа и выводить их в консоль: 

#include <stdio.h>
int triangle (int n) {
    if (n == 1)
        return 1;
    else
        return n + triangle(n - 1);
}

void printPyramid (int n) {
    int i = 1;
    while (i <= n) {
        int amnt = i;
        char shift[5];
        sprintf(shift, "%%%dd", n + 1 - i);
        printf(shift, i);
        while (--amnt != 0) {
            printf(" %d", i);
        }
        printf("\n");
        i++;
    }
}

void printTriangle (int n) {
    int prev = 0;
    while (n > 0) {
        prev++;
        n -= prev;
        printf("%s%d", (prev > 1) ? " + " : "", prev);
    }
    printf("\n");
}

int main (int argc, const char* argv[]) {
    printPyramid(5);
    printTriangle(triangle(5));
    printf("%d", triangle(5));
}

////////////5.3 Переходим к факториалам числа. Немного вспомним математику и напишем:
3! = 3*2*1*1 – факториал числа 3 равен произведению 1 на 2 и на 3. Почему 1 мы записали два раза, это не ошибка и мы сейчас в этом убедимся. Запишем рекуррентное соотношение для факториала числа:
N! = N*(N-1)!
	0! = 1;
т.е. факториал числа равен самому числу, умноженному на факториал предыдущего числа. Факториал 0 равен 1. Тогда расчет 3! будет выглядеть так:
3! = 3*2! = 3*2*1! = 3*2*1*0! = 3*2*1*1.
Давайте напишем это в коде.
 int factorial( int a) {
if ( a == 0 ) 
return 1;
else
return a*factorial(a-1);
}
int main ( int argc , char * argv []) {
int n;
printf ( "Input number:" );
scanf ( "%d" , & n );
printf ( "Summ digit:%d" , factorial( n ));
return 0;
}
Как и в предыдущем примере, условием выхода из рекурсивного вызова будет а = 0. 
Обратите внимание на недостаток этого алгоритма, если вызвать функцию factorial с параметром -1, рекурсия никогда не остановится. 
-1! = -1*-2! = -1*-2*-3! = -1*-2*-3*-4!....
Чтобы этого избежать, изменим условие оператора if на а <= 0, функция не будет считать факториалы отрицательных чисел, но и выполнятся бесконечно тоже не будет. 
Теперь можем сделать важный вывод – рекурсия должна быть конечной. Всегда при написании рекурсивных методов необходимо следить за выходом из рекурсивного вызова.
Немного отвлечемся и поговорим стеке вызовов. Для работы программы в памяти компьютера выделяются две области памяти: стек и хип (куча). Когда часть кода вызывает функцию, информация о вызове находится в стеке. Как только функция завершает работу - информация из стека выталкивается и программа возобновляет свою работу с места, на котором остановилась. Список вызовов функций называется стеком вызова. 
Рекурсивные методы обладают количественной мерой – глубиной. Глубиной рекурсии называется максимальное число вложенных рекурсивных вызовов. Так вот иногда может возникать  очень глубокая рекурсия, что приводит к большому расходу стекового пространства, вплоть до его переполнения со всеми вытекающими последствиями, и зависанию программы. 

//////////////// 5.4 Далее рассмотрим числа Фибоначчи.
Числа Фибоначчи это элементы числовой последовательности вида:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34…
т.е. в ней первые два числа равны либо 1 и 1, либо 0 и 1, а каждое последующее число равно сумме двух предыдущих. Названы в честь средневекового математика Леонардо Пизанского, известного как Фибоначчи.
Давайте напишем рекуррентное соотношение последовательности {Fn}:
F0 = 0,
F0 = 1,
Fn = Fn-1 + Fn-2 для n > 1
Согласно нашему рекуррентному соотношению напишем алгоритм:
int long fib ( int n) { // объявим функцию fib которая возвращает long 
if ( n == 0 ) return 0; // первое условие
if ( n == 1 ) return 1; // второе условие
return fib ( n - 1 ) + fib ( n - 2 ); // и собственно реализация третьего условия
}
int main ( int argc , char * argv [])
{
int i;
for ( i = 0 ; i < 20 ; i ++) // напишем цикл от 0 до 20, вызовем в нем нашу функцию 
printf ( "%d " , fib ( i )); // и передадим ей в качестве аргумента i.
return 0;
}
Приведенный алгоритм достаточно прост для понимания, но работает довольно медленно. Например для расчета значения fib(6) программе потребуется определить значения fib(5) и fib(4), но перед расчетом fib(5) ей потребуется определить значения fib(4) и fib(3), т.е. fib(4) будет определяться дважды. При больших значениях n рекурсия fib(n) становится достаточно глубокой, а одни и те же значения приходится находить большое количество раз. 

/////////////5.5 Анаграммы.
Анаграмма — это игра со словами, когда в результате перестановки букв слова или фразы получаем другое слово или фразу. Два слова являются анаграммами, если мы можем получить одно из другого переставляя буквы местами.
Допустим, у нас есть некий машинный алфавит и в нем всего четыре буквы «m», «o», «r», «e». Нам нужно получить все слова из этих букв. Количество букв обозначим len. Будем определять буквы слова последовательно, одну за другой. Первая буква может быть любой из четырех. Предположим что сначала поставим «m». Тогда, чтобы получить все варианты с первой буквой «m», нужно перебрать все возможные комбинации букв, оставшихся len-1 позиций. Далее ставим на первое место остальные буквы, при этом повторяя процедуру перебора.
w[0] = ’m’; //перебор последних символов без первого
w[0] = ’o’; //перебор последних символов без первого
w[0] = ’r’; //перебор последних символов без первого
w[0] = ’e’; //перебор последних символов без первого
т.е. задача длины len сведена к четырем задачам длины len-1.
Давайте рассмотрим на примере:
int count = 0;
void more () {
char word [] = "..." ; // Длина слова. Чем больше точек, тем длиннее слово
findWords ( "more" , word , 0 );
}
void findWords ( char * A , char * word , int N) {
if ( N == strlen ( word )) {  // Слово построено
printf ( "%d %s\n" , ++ count , word );
return;
}
int i;
char * w;
w = word;
for ( I = 0 ; I < strlen ( A ); i ++) {
w [ N ] = A [ i ];
findWords ( A , w , N + 1 ); // Рекурсия
}
}

int main ( int argc , char * argv []) {
more ();
return 0;
}

////////////5.6 Ханойская башня
	Ханойская башня это задача в которой дано три стержня, на один из которых нанизано 8 колец, меньшее на большем. Нужно перенести все кольца на другой стержень за наименьшее количество ходов, причём можно за один ход брать только одно кольцо, и нельзя класть большее кольцо на меньшее. Классическая задача рекурсии. Нам нужно научиться перекладывать одно кольцо на другой стержень, а затем поставить перед собой задачу - переложить n-1 колец на временный стержень, переложить то самое одно кольцо на конечный, и затем переложить n-1 колец со временного на конечный. 
Заведём счётчик операций, для того чтобы немного отформатировать вывод, и вообще для интереса. Напишем функцию, которая будет говорить нам с какого на какой стержень надо переложить кольцо. и основную функцию, которая будет решать поставленную пару минут назад задачу.
	int operations = 0;
	void put(int from, int to) {
	    printf("%d -> %d | ", from, to);
			if ((++operations % 5) == 0) printf("\n");
	}
	void move_to(int from, int to, int n) {
	    int temp = from ^ to;
			if (n == 1) 
			    put(from, to);
			else {
			    move_to(from, temp, n-1);
					put(from, to);
					move_to(temp, to, n-1);
			}
	}
	int two_main() {
	    int rings = 8;
			printf("pyramid size: %d\n", rings);
			move_to(1, 3, rings);
			printf("\n Operations: %d\n", operations);
			return 0;
	}
Вот и всё решение. Обратите внимание на то, что мы, написав рекурсивную функцию, решаем задачу абстрактно, не задумываясь о том как именно переложить пятое или седьмое или третье кольцо. Это делается аналогично предыдущим кольцам. Взяли н-1 как то откинули (а как? взяли н-минус-ещё-1, а их как? взяли н-1-1-1... и так пока н не будет == 1) взяли одно кольцо, переместили, и затем взяли н-1 колец и положили на нужное место.

//////////////5.7 Поиск последовательности (наибольшая общая подпоследовательность)
Определение - некая последовательность является подпоследовательностью какой-то другой последовательности, если существует строго возрастающая последовательнось индексов обеих последовательностей. то есть например последовательность bcdb является подпоследовательностью подследовательности abcbdab, а соответствующая последовательность индексов имеет вид 2-3-5-7. Задача поиска наибольшей общей подпоследовательности является классической задачей программирования. 
	Итак пусть имеются последовательности x(1...n) и y(1...m) необходимо найти НОП(х, у). Подумаем о рекуррентном соотношении:
LCS(x, y) = 0, if x = 0 or y = 0;
LCS(x, y) = LCS(x - 1, y - 1) + 1, if x[i] == y[i];
LCS(x, y) = max of (LCS(x, y-1), LCS(x-1, y)), if x[i] != y[i];
и реализуем его на языке С

#include <stdio.h>
#include <math.h>

int lcs_length(char * A, char * B)
{
	if (*A == '\0' || *B == '\0')
		return 0;
	else if (*A == *B)
		return 1 + lcs_length(A+1, B+1);
	else
	{
		int x1 = lcs_length(A + 1, B);
		int x2 = lcs_length(A, B + 1);
		return (x1 > x2) ? x1 : x2;
	}
}


int main() {
	char* x = "abcdef";
	char* y = "abef";
	printf("result = %d ", lcs_length(x, y));
	getchar();
	getchar();
	return 0;
}

